{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kami Pricing Analytics","text":""},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>About</li> <li>Getting Started</li> <li>Usage</li> <li>Running Tests</li> </ul>"},{"location":"#about","title":"About","text":"<p>This project is designed to be a scalable Kami Pricing Analytics, initially focused on extracting product seller information from the \"Beleza Na Web\" marketplace. Built with FastAPI for its asynchronous support and easy-to-use routing, it aims to provide a robust foundation for scraping various marketplaces by extending the service with minimal effort. The project structure supports the SOLID principles, clean code practices, and is ready for Test-Driven Development (TDD) and future scalability considerations, including integration with Celery for task queuing and Traefik for load balancing.</p> <p>Given your project's Taskipy settings for task automation with Poetry, let's revise the \"Getting Started\" section to incorporate these tasks into the workflow. This ensures developers are guided to use Taskipy commands for linting, testing, and coverage reporting, enhancing code quality and consistency.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Follow these instructions to set up the project on your local machine for development, testing, and potential contributions. You have the option to run the project locally using Poetry and Taskipy tasks or within a Docker container.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Ensure Python 3.11+ is installed on your system.</li> <li>Install Poetry for dependency management.</li> <li>For Docker users, install Docker and Docker Compose.</li> </ul>"},{"location":"#installing-with-poetry","title":"Installing with Poetry","text":"<ol> <li>Clone the Repository:</li> </ol> <p>```bash    git clone https://github.com/devkami/kami-pricing-scraper.git    cd kami-pricing-scraper</p> <p>```</p> <ol> <li>Install Dependencies:</li> </ol> <p><code>bash    poetry install</code></p> <ol> <li>Activate Virtual Environment:</li> </ol> <p><code>bash    poetry shell</code></p> <ol> <li>Run Linting (Optional):</li> </ol> <p>Before starting the server or committing your changes, you can lint your code:</p> <ul> <li> <p>To review linting errors without applying changes:</p> <p><code>bash  poetry run task lint-review</code></p> </li> <li> <p>To automatically format and sort your imports:</p> <p><code>bash  poetry run task lint</code></p> </li> <li> <p>Start the FastAPI Server:</p> </li> </ul> <p><code>bash    uvicorn scraper.app:app --reload</code></p> <p>Access the application at <code>http://localhost:8000</code> and the Swagger UI at <code>http://localhost:8000/docs</code>.</p>"},{"location":"#running-with-docker","title":"Running with Docker","text":"<p>Build and run the Docker container:</p> <pre><code>docker-compose up --build\n</code></pre> <p>This makes your FastAPI application accessible at <code>http://localhost:8001</code>, with Swagger UI available at <code>http://localhost:8001/docs</code>.</p>"},{"location":"#usage","title":"Usage","text":"<p>To use the microservice, make a POST request to <code>/scrap/</code> with a JSON body containing the <code>product_url</code>. For example:</p> <pre><code>{\n  \"product_url\": \"https://www.belezanaweb.com.br/some-product\"\n}\n</code></pre> <p>The service will return a JSON response with seller information extracted from the product page.</p>"},{"location":"#running-tests","title":"Running Tests","text":"<p>To maintain and verify application functionality:</p> <ul> <li> <p>Using Taskipy and Poetry:</p> </li> <li> <p>To run tests with coverage reporting:</p> <p><code>bash poetry run task test</code></p> </li> <li> <p>Coverage reports are generated in HTML format by the <code>post_test</code> task and can be found in the <code>htmlcov</code> directory.</p> </li> <li> <p>Using Docker:</p> </li> </ul> <p>For Docker users, run tests within the Docker environment:</p> <p><code>bash   docker-compose run web poetry run task test</code></p>"},{"location":"data_collector/base-collector/","title":"Collector","text":"<p>This document provides details about the basics functionality for a successfull data extraction. Below is the auto-generated documentation for the <code>BaseCollector</code>, <code>CollectorOptions</code> and <code>MarketPlaceOptions</code> classes.</p> <p>Base Collector </p> <p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Abstract base class defining a strategy for data collection or processing. This class serves as a template for specific strategies that work with products or resources identified by URLs or SKU.</p> <p>Attributes:</p> Name Type Description <code>product_url</code> <code>HttpUrl</code> <p>The URL of the product or resource that the strategy will work with.</p> <code>sku</code> <code>str</code> <p>The Stock Keeping Unit (SKU) of the product, if available.</p> <p>Methods:</p> Name Description <code>execute</code> <p>Abstract method that must be implemented by subclasses. This method is intended to carry out the specific actions of the strategy.</p> Source code in <code>kami_pricing_analytics/data_collector/base_collector.py</code> <pre><code>class BaseCollector(BaseModel, ABC):\n    \"\"\"\n    Abstract base class defining a strategy for data collection or processing. This class\n    serves as a template for specific strategies that work with products or resources\n    identified by URLs or SKU.\n\n    Attributes:\n        product_url (HttpUrl): The URL of the product or resource that the strategy will work with.\n        sku (str): The Stock Keeping Unit (SKU) of the product, if available.\n\n    Methods:\n        execute(): Abstract method that must be implemented by subclasses. This method is intended to carry out the specific actions of the strategy.\n    \"\"\"\n\n    product_url: HttpUrl\n    sku: str = None\n\n    @abstractmethod\n    def execute(self) -&gt; dict:\n        \"\"\"\n        Executes the strategy's core logic on the specified product or resource.\n\n        This method should be implemented by subclasses to perform specific actions,\n        such as data collection, analysis, or any other process relevant to the\n        strategy being implemented.\n\n        Returns:\n            dict: The result of the strategy's execution. The structure of the return\n            value should be documented by subclasses.\n        \"\"\"\n        pass\n</code></pre> <p>Collector Options </p> <p>               Bases: <code>Enum</code></p> <p>Enumeration of supported pricing strategies.</p> <p>Attributes:</p> Name Type Description <code>WEB_SCRAPING</code> <code>int</code> <p>Web scraping strategy.</p> <code>GOOGLE_SHOPPING</code> <code>int</code> <p>Google Shopping strategy.</p> Source code in <code>kami_pricing_analytics/data_collector/base_collector.py</code> <pre><code>class CollectorOptions(Enum):\n    \"\"\"\n    Enumeration of supported pricing strategies.\n\n    Attributes:\n        WEB_SCRAPING (int): Web scraping strategy.\n        GOOGLE_SHOPPING (int): Google Shopping strategy.\n    \"\"\"\n\n    WEB_SCRAPING = 0\n    GOOGLE_SHOPPING = 1\n\n    @classmethod\n    def get_strategy_name(cls, value) -&gt; str:\n        \"\"\"\n        Returns the name of the strategy based on the provided value.\n\n        Args:\n            value (int): The value of the strategy.\n\n        Returns:\n            str: The name of the strategy.\n\n        Raises:\n            KeyError: If the provided value is not a valid strategy.\n        \"\"\"\n        try:\n            strategy_mapping = {\n                cls.WEB_SCRAPING.value: 'web_scraping',\n                cls.GOOGLE_SHOPPING.value: 'google_shopping',\n            }\n        except KeyError:\n            raise KeyError(f'Invalid strategy value: {value}')\n\n        return strategy_mapping.get(value, None)\n</code></pre> <p>MarketPlace Options </p> <p>               Bases: <code>Enum</code></p> <p>Enumeration of supported marketplaces.</p> <p>Attributes:</p> Name Type Description <code>BELEZA_NA_WEB</code> <code>tuple</code> <p>Beleza na Web marketplace.</p> <code>AMAZON</code> <code>tuple</code> <p>Amazon marketplace.</p> <code>MERCADO_LIVRE</code> <code>tuple</code> <p>Mercado Livre marketplace.</p> Source code in <code>kami_pricing_analytics/data_collector/base_collector.py</code> <pre><code>class MarketPlaceOptions(Enum):\n    \"\"\"\n    Enumeration of supported marketplaces.\n\n    Attributes:\n        BELEZA_NA_WEB (tuple): Beleza na Web marketplace.\n        AMAZON (tuple): Amazon marketplace.\n        MERCADO_LIVRE (tuple): Mercado Livre marketplace.\n    \"\"\"\n\n    BELEZA_NA_WEB = ('beleza_na_web', None)\n    AMAZON = ('amazon', 'https://www.amazon.com.br/dp/{marketplace_id}')\n    MERCADO_LIVRE = (\n        'mercado_livre',\n        'https://produto.mercadolivre.com.br/{marketplace_id}',\n    )\n\n    def __init__(self, name, url_pattern):\n        self._name = name\n        self.url_pattern = url_pattern\n\n    @staticmethod\n    def format_mercado_libre_id(marketplace_id) -&gt; str:\n        \"\"\"\n        Formats the Mercado Livre marketplace ID.\n\n        Args:\n            marketplace_id (str): The marketplace ID.\n\n        Returns:\n            str: The formatted marketplace ID.\n\n        Raises:\n            ValueError: If the marketplace ID is not in the correct format.\n        \"\"\"\n        marketplace_id = ''\n        try:\n            if not marketplace_id.startswith('MLB-'):\n                if marketplace_id.startswith('MLB'):\n                    marketplace_id = f'MLB-{marketplace_id[3:]}'\n                else:\n                    marketplace_id = f'MLB-{marketplace_id}'\n        except ValueError:\n            raise ValueError(f'Invalid Mercado Livre ID: {marketplace_id}')\n        return marketplace_id\n\n    def build_url(self, marketplace_id) -&gt; str:\n        \"\"\"\n        Builds the URL for the marketplace based on the provided marketplace ID.\n\n        Args:\n            marketplace_id (str): The marketplace ID.\n\n        Returns:\n            str: The URL for the marketplace.\n\n        Raises:\n            ValueError: If the marketplace ID is not in the correct format.\n        \"\"\"\n        url = ''\n\n        try:\n            if self.name == 'MERCADO_LIVRE':\n                marketplace_id = self.format_mercado_libre_id(\n                    marketplace_id=marketplace_id\n                )\n            if self.url_pattern:\n                url = self.url_pattern.format(marketplace_id=marketplace_id)\n        except Exception as e:\n            raise ValueError(f'Error building URL: {e}')\n        return url\n</code></pre>"},{"location":"data_collector/base-collector/#kami_pricing_analytics.data_collector.BaseCollector.execute","title":"<code>execute()</code>  <code>abstractmethod</code>","text":"<p>Executes the strategy's core logic on the specified product or resource.</p> <p>This method should be implemented by subclasses to perform specific actions, such as data collection, analysis, or any other process relevant to the strategy being implemented.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The result of the strategy's execution. The structure of the return</p> <code>dict</code> <p>value should be documented by subclasses.</p> Source code in <code>kami_pricing_analytics/data_collector/base_collector.py</code> <pre><code>@abstractmethod\ndef execute(self) -&gt; dict:\n    \"\"\"\n    Executes the strategy's core logic on the specified product or resource.\n\n    This method should be implemented by subclasses to perform specific actions,\n    such as data collection, analysis, or any other process relevant to the\n    strategy being implemented.\n\n    Returns:\n        dict: The result of the strategy's execution. The structure of the return\n        value should be documented by subclasses.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/base-collector/#kami_pricing_analytics.data_collector.CollectorOptions.get_strategy_name","title":"<code>get_strategy_name(value)</code>  <code>classmethod</code>","text":"<p>Returns the name of the strategy based on the provided value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value of the strategy.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the strategy.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the provided value is not a valid strategy.</p> Source code in <code>kami_pricing_analytics/data_collector/base_collector.py</code> <pre><code>@classmethod\ndef get_strategy_name(cls, value) -&gt; str:\n    \"\"\"\n    Returns the name of the strategy based on the provided value.\n\n    Args:\n        value (int): The value of the strategy.\n\n    Returns:\n        str: The name of the strategy.\n\n    Raises:\n        KeyError: If the provided value is not a valid strategy.\n    \"\"\"\n    try:\n        strategy_mapping = {\n            cls.WEB_SCRAPING.value: 'web_scraping',\n            cls.GOOGLE_SHOPPING.value: 'google_shopping',\n        }\n    except KeyError:\n        raise KeyError(f'Invalid strategy value: {value}')\n\n    return strategy_mapping.get(value, None)\n</code></pre>"},{"location":"data_collector/base-collector/#kami_pricing_analytics.data_collector.MarketPlaceOptions.build_url","title":"<code>build_url(marketplace_id)</code>","text":"<p>Builds the URL for the marketplace based on the provided marketplace ID.</p> <p>Parameters:</p> Name Type Description Default <code>marketplace_id</code> <code>str</code> <p>The marketplace ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The URL for the marketplace.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the marketplace ID is not in the correct format.</p> Source code in <code>kami_pricing_analytics/data_collector/base_collector.py</code> <pre><code>def build_url(self, marketplace_id) -&gt; str:\n    \"\"\"\n    Builds the URL for the marketplace based on the provided marketplace ID.\n\n    Args:\n        marketplace_id (str): The marketplace ID.\n\n    Returns:\n        str: The URL for the marketplace.\n\n    Raises:\n        ValueError: If the marketplace ID is not in the correct format.\n    \"\"\"\n    url = ''\n\n    try:\n        if self.name == 'MERCADO_LIVRE':\n            marketplace_id = self.format_mercado_libre_id(\n                marketplace_id=marketplace_id\n            )\n        if self.url_pattern:\n            url = self.url_pattern.format(marketplace_id=marketplace_id)\n    except Exception as e:\n        raise ValueError(f'Error building URL: {e}')\n    return url\n</code></pre>"},{"location":"data_collector/base-collector/#kami_pricing_analytics.data_collector.MarketPlaceOptions.format_mercado_libre_id","title":"<code>format_mercado_libre_id(marketplace_id)</code>  <code>staticmethod</code>","text":"<p>Formats the Mercado Livre marketplace ID.</p> <p>Parameters:</p> Name Type Description Default <code>marketplace_id</code> <code>str</code> <p>The marketplace ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted marketplace ID.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the marketplace ID is not in the correct format.</p> Source code in <code>kami_pricing_analytics/data_collector/base_collector.py</code> <pre><code>@staticmethod\ndef format_mercado_libre_id(marketplace_id) -&gt; str:\n    \"\"\"\n    Formats the Mercado Livre marketplace ID.\n\n    Args:\n        marketplace_id (str): The marketplace ID.\n\n    Returns:\n        str: The formatted marketplace ID.\n\n    Raises:\n        ValueError: If the marketplace ID is not in the correct format.\n    \"\"\"\n    marketplace_id = ''\n    try:\n        if not marketplace_id.startswith('MLB-'):\n            if marketplace_id.startswith('MLB'):\n                marketplace_id = f'MLB-{marketplace_id[3:]}'\n            else:\n                marketplace_id = f'MLB-{marketplace_id}'\n    except ValueError:\n        raise ValueError(f'Invalid Mercado Livre ID: {marketplace_id}')\n    return marketplace_id\n</code></pre>"},{"location":"data_collector/collector-factory/","title":"Collector Factory","text":"<p>This document provides details about Collector Factory functionality. Below is the auto-generated documentation for the <code>CollectorFactory</code> class.</p> <p>Factory class for creating scraper instances based on the specified strategy and marketplace. This class allows for the dynamic selection of scraping strategies based on the provided product URL, optimizing the scraping process for different marketplaces.</p> <p>Methods:</p> Name Description <code>get_strategy </code> <p>Returns an instance of a scraper strategy based on the marketplace identified in the product URL.</p> Source code in <code>kami_pricing_analytics/data_collector/collector_factory.py</code> <pre><code>class CollectorFactory:\n    \"\"\"\n    Factory class for creating scraper instances based on the specified strategy\n    and marketplace. This class allows for the dynamic selection of scraping strategies\n    based on the provided product URL, optimizing the scraping process for different\n    marketplaces.\n\n    Methods:\n        get_strategy (int, str) -&gt; BaseScraper: Returns an instance of a scraper strategy based on the marketplace identified in the product URL.\n    \"\"\"\n\n    @staticmethod\n    def get_strategy(collector_option: int, product_url: str) -&gt; BaseScraper:\n        \"\"\"\n        Determines the appropriate scraper instance to use based on the marketplace\n        in the product URL and the selected strategy option.\n\n        Args:\n            collector_option (int): Numeric identifier for the scraping strategy to use.\n            product_url (str): URL of the product to be scraped.\n\n        Returns:\n            strategy (BaseScraper): An instance of a scraper appropriate for the identified marketplace.\n\n        Raises:\n            ValueError: If no appropriate scraper is found for the marketplace or if\n                        the strategy option is not supported.\n        \"\"\"\n\n        strategy = BaseScraper\n\n        if collector_option != CollectorOptions.WEB_SCRAPING.value:\n            raise ValueError('Unsupported strategy option')\n\n        if 'belezanaweb' in product_url:\n            strategy = BelezaNaWebScraper(product_url=product_url)\n        elif 'amazon' in product_url:\n            strategy = AmazonScraper(product_url=product_url)\n        elif 'mercadolivre' in product_url:\n            strategy = MercadoLibreScraper(product_url=product_url)\n        else:\n            raise ValueError('Unsupported marketplace for web scraping')\n\n        return strategy\n</code></pre>"},{"location":"data_collector/collector-factory/#kami_pricing_analytics.data_collector.CollectorFactory.get_strategy","title":"<code>get_strategy(collector_option, product_url)</code>  <code>staticmethod</code>","text":"<p>Determines the appropriate scraper instance to use based on the marketplace in the product URL and the selected strategy option.</p> <p>Parameters:</p> Name Type Description Default <code>collector_option</code> <code>int</code> <p>Numeric identifier for the scraping strategy to use.</p> required <code>product_url</code> <code>str</code> <p>URL of the product to be scraped.</p> required <p>Returns:</p> Name Type Description <code>strategy</code> <code>BaseScraper</code> <p>An instance of a scraper appropriate for the identified marketplace.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no appropriate scraper is found for the marketplace or if         the strategy option is not supported.</p> Source code in <code>kami_pricing_analytics/data_collector/collector_factory.py</code> <pre><code>@staticmethod\ndef get_strategy(collector_option: int, product_url: str) -&gt; BaseScraper:\n    \"\"\"\n    Determines the appropriate scraper instance to use based on the marketplace\n    in the product URL and the selected strategy option.\n\n    Args:\n        collector_option (int): Numeric identifier for the scraping strategy to use.\n        product_url (str): URL of the product to be scraped.\n\n    Returns:\n        strategy (BaseScraper): An instance of a scraper appropriate for the identified marketplace.\n\n    Raises:\n        ValueError: If no appropriate scraper is found for the marketplace or if\n                    the strategy option is not supported.\n    \"\"\"\n\n    strategy = BaseScraper\n\n    if collector_option != CollectorOptions.WEB_SCRAPING.value:\n        raise ValueError('Unsupported strategy option')\n\n    if 'belezanaweb' in product_url:\n        strategy = BelezaNaWebScraper(product_url=product_url)\n    elif 'amazon' in product_url:\n        strategy = AmazonScraper(product_url=product_url)\n    elif 'mercadolivre' in product_url:\n        strategy = MercadoLibreScraper(product_url=product_url)\n    else:\n        raise ValueError('Unsupported marketplace for web scraping')\n\n    return strategy\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/","title":"Amazon Scraper","text":"<p>This document provides details about the Amazon scraper functionality. Below is the auto-generated documentation for the <code>AmazonScraper</code> class.</p> <p>               Bases: <code>BaseScraper</code></p> <p>Scraper specifically designed for the Amazon marketplace. It extracts seller information such as marketplace ID, brand, description, and pricing data from product pages.</p> Inherits from <p>BaseScraper (class): Abstract base class for scraping strategies.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>class AmazonScraper(BaseScraper):\n    \"\"\"\n    Scraper specifically designed for the Amazon marketplace. It extracts seller information such as marketplace ID, brand, description, and pricing data from product pages.\n\n    Inherits from:\n        BaseScraper (class): Abstract base class for scraping strategies.\n    \"\"\"\n\n    def __init__(self, **data):\n        \"\"\"\n        Initializes the scraper with a specific logger for 'Amazon'.\n        \"\"\"\n        super().__init__(**data, logger_name='amazon-scraper')\n\n    async def get_marketplace_id(self) -&gt; str:\n        \"\"\"\n        Extracts the marketplace ID from the product page.\n\n        Returns:\n            str: The marketplace ID.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n        marketplace_id = ''\n        try:\n            marketplace_id = self.webdriver.find_element(\n                By.XPATH,\n                '//th[contains(text(), \"ASIN\")]/following-sibling::td',\n            ).text.strip()\n        except Exception as e:\n            raise AmazonScraperException(f'Error while getting ASIN: {e}')\n\n        return marketplace_id\n\n    async def get_brand(self) -&gt; str:\n        \"\"\"\n        Extracts the brand from the product page.\n\n        Returns:\n            str: The brand.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n\n        brand = ''\n        try:\n            brand = self.webdriver.find_element(\n                By.XPATH,\n                '//th[contains(text(), \"Fabricante\")]/following-sibling::td',\n            ).text.strip()\n        except Exception as e:\n            raise AmazonScraperException(\n                f'Error while getting product brand: {e}'\n            )\n\n        return brand\n\n    async def get_description(self) -&gt; str:\n        \"\"\"\n        Extracts the description from the product page.\n\n        Returns:\n            str: The description.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n        description = ''\n        try:\n            description = self.webdriver.find_element(\n                By.ID, 'title'\n            ).text.strip()\n        except Exception as e:\n            raise AmazonScraperException(\n                f'Error while getting product description: {e}'\n            )\n\n        return description\n\n    async def get_price(self, seller: WebElement) -&gt; str:\n        \"\"\"\n        Extracts the price from the seller's data.\n\n        Args:\n            seller (WebElement): The seller element.\n\n        Returns:\n            str: The price.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n        price = ''\n        try:\n            price = seller.find_element(\n                By.CSS_SELECTOR, 'span.a-offscreen'\n            ).get_attribute('innerHTML')\n        except Exception as e:\n            raise AmazonScraperException(\n                f'Error while getting product price: {e}'\n            )\n\n        return price\n\n    async def get_seller_id(self, seller: WebElement) -&gt; str:\n        \"\"\"\n        Extracts the seller ID from the seller's data.\n\n        Args:\n            seller (WebElement): The seller element.\n\n        Returns:\n            str: The seller ID.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n        seller_id = ''\n        try:\n            seller_link = seller.find_element(\n                By.CSS_SELECTOR, 'a.a-size-small.a-link-normal'\n            ).get_attribute('href')\n            seller_id = parse_qs(urlparse(seller_link).query).get(\n                'seller', [None]\n            )[0]\n        except Exception as e:\n            raise AmazonScraperException(f'Error while getting seller id: {e}')\n\n        return seller_id\n\n    async def get_seller_name(self, seller: WebElement) -&gt; str:\n        \"\"\"\n        Extracts the seller name from the seller's data.\n\n        Args:\n            seller (WebElement): The seller element.\n\n        Returns:\n            str: The seller name.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n        seller_name = ''\n        try:\n            seller_name = seller.find_element(\n                By.CSS_SELECTOR, 'a.a-size-small.a-link-normal'\n            ).get_attribute('innerHTML')\n        except Exception as e:\n            raise AmazonScraperException(\n                f'Error while getting seller name: {e}'\n            )\n\n        return seller_name.strip()\n\n    async def get_seller_url(self, seller: WebElement) -&gt; str:\n        \"\"\"\n        Extracts the seller URL from the seller's data.\n\n        Args:\n            seller (WebElement): The seller element.\n\n        Returns:\n            str: The seller URL.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n        seller_url = ''\n        try:\n            seller_url = seller.find_element(\n                By.CSS_SELECTOR, 'a.a-size-small.a-link-normal'\n            ).get_attribute('href')\n        except Exception as e:\n            raise AmazonScraperException(\n                f'Error while getting seller url: {e}'\n            )\n\n        return seller_url\n\n    async def get_sellers_list(self) -&gt; List[Dict]:\n        \"\"\"\n        Extracts the list of sellers from the product page.\n\n        Returns:\n            List[Dict]: A list of dictionaries, each containing data about a seller.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n\n        sellers = []\n        try:\n            self.webdriver.get(str(self.product_url))\n            clickable_element = self.webdriver.find_element(\n                By.XPATH,\n                '//div[@class=\"a-section a-spacing-none daodi-content\"]//a[@class=\"a-link-normal\"]',\n            )\n            clickable_element.click()\n            WebDriverWait(self.webdriver, 10).until(\n                EC.visibility_of_element_located((By.ID, 'aod-offer-list'))\n            )\n            sellers_offers = self.webdriver.find_elements(\n                By.CSS_SELECTOR, '#aod-offer-list #aod-offer'\n            )\n            for seller_offer in sellers_offers:\n                seller = {\n                    'product_url': self.product_url,\n                    'marketplace_id': '',\n                    'brand': '',\n                    'description': '',\n                    'price': '',\n                    'seller_id': '',\n                    'seller_name': '',\n                    'seller_url': '',\n                }\n                seller['price'] = await self.get_price(seller_offer)\n                seller['seller_id'] = await self.get_seller_id(seller_offer)\n                seller['seller_name'] = await self.get_seller_name(\n                    seller_offer\n                )\n                seller['seller_url'] = await self.get_seller_url(seller_offer)\n                sellers.append(seller)\n        except Exception as e:\n            raise AmazonScraperException(\n                f'Error while getting sellers list: {e}'\n            )\n\n        return sellers\n\n    async def get_seller_info(self, seller: Dict) -&gt; Dict:\n        \"\"\"\n        Extracts the seller information from the product page.\n\n        Args:\n            seller (Dict): The seller element.\n\n        Returns:\n            Dict: A dictionary containing the seller's information.\n\n        Raises:\n            AmazonScraperException: If an error occurs during extraction.\n        \"\"\"\n        try:\n            self.webdriver.get(str(self.product_url))\n            seller['marketplace_id'] = await self.get_marketplace_id()\n            seller['brand'] = await self.get_brand()\n            seller['description'] = await self.get_description()\n\n        except AmazonScraperException as e:\n            self.logger.error(f'Error while getting seller info details: {e}')\n        except Exception as e:\n            self.logger.error(\n                f'Unexpected error while getting seller info: {e}'\n            )\n\n        return seller\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.__init__","title":"<code>__init__(**data)</code>","text":"<p>Initializes the scraper with a specific logger for 'Amazon'.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>def __init__(self, **data):\n    \"\"\"\n    Initializes the scraper with a specific logger for 'Amazon'.\n    \"\"\"\n    super().__init__(**data, logger_name='amazon-scraper')\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_brand","title":"<code>get_brand()</code>  <code>async</code>","text":"<p>Extracts the brand from the product page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The brand.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_brand(self) -&gt; str:\n    \"\"\"\n    Extracts the brand from the product page.\n\n    Returns:\n        str: The brand.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n\n    brand = ''\n    try:\n        brand = self.webdriver.find_element(\n            By.XPATH,\n            '//th[contains(text(), \"Fabricante\")]/following-sibling::td',\n        ).text.strip()\n    except Exception as e:\n        raise AmazonScraperException(\n            f'Error while getting product brand: {e}'\n        )\n\n    return brand\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_description","title":"<code>get_description()</code>  <code>async</code>","text":"<p>Extracts the description from the product page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The description.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_description(self) -&gt; str:\n    \"\"\"\n    Extracts the description from the product page.\n\n    Returns:\n        str: The description.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n    description = ''\n    try:\n        description = self.webdriver.find_element(\n            By.ID, 'title'\n        ).text.strip()\n    except Exception as e:\n        raise AmazonScraperException(\n            f'Error while getting product description: {e}'\n        )\n\n    return description\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_marketplace_id","title":"<code>get_marketplace_id()</code>  <code>async</code>","text":"<p>Extracts the marketplace ID from the product page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The marketplace ID.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_marketplace_id(self) -&gt; str:\n    \"\"\"\n    Extracts the marketplace ID from the product page.\n\n    Returns:\n        str: The marketplace ID.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n    marketplace_id = ''\n    try:\n        marketplace_id = self.webdriver.find_element(\n            By.XPATH,\n            '//th[contains(text(), \"ASIN\")]/following-sibling::td',\n        ).text.strip()\n    except Exception as e:\n        raise AmazonScraperException(f'Error while getting ASIN: {e}')\n\n    return marketplace_id\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_price","title":"<code>get_price(seller)</code>  <code>async</code>","text":"<p>Extracts the price from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>WebElement</code> <p>The seller element.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The price.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_price(self, seller: WebElement) -&gt; str:\n    \"\"\"\n    Extracts the price from the seller's data.\n\n    Args:\n        seller (WebElement): The seller element.\n\n    Returns:\n        str: The price.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n    price = ''\n    try:\n        price = seller.find_element(\n            By.CSS_SELECTOR, 'span.a-offscreen'\n        ).get_attribute('innerHTML')\n    except Exception as e:\n        raise AmazonScraperException(\n            f'Error while getting product price: {e}'\n        )\n\n    return price\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_seller_id","title":"<code>get_seller_id(seller)</code>  <code>async</code>","text":"<p>Extracts the seller ID from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>WebElement</code> <p>The seller element.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The seller ID.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_seller_id(self, seller: WebElement) -&gt; str:\n    \"\"\"\n    Extracts the seller ID from the seller's data.\n\n    Args:\n        seller (WebElement): The seller element.\n\n    Returns:\n        str: The seller ID.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n    seller_id = ''\n    try:\n        seller_link = seller.find_element(\n            By.CSS_SELECTOR, 'a.a-size-small.a-link-normal'\n        ).get_attribute('href')\n        seller_id = parse_qs(urlparse(seller_link).query).get(\n            'seller', [None]\n        )[0]\n    except Exception as e:\n        raise AmazonScraperException(f'Error while getting seller id: {e}')\n\n    return seller_id\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_seller_info","title":"<code>get_seller_info(seller)</code>  <code>async</code>","text":"<p>Extracts the seller information from the product page.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>Dict</code> <p>The seller element.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>A dictionary containing the seller's information.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_seller_info(self, seller: Dict) -&gt; Dict:\n    \"\"\"\n    Extracts the seller information from the product page.\n\n    Args:\n        seller (Dict): The seller element.\n\n    Returns:\n        Dict: A dictionary containing the seller's information.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n    try:\n        self.webdriver.get(str(self.product_url))\n        seller['marketplace_id'] = await self.get_marketplace_id()\n        seller['brand'] = await self.get_brand()\n        seller['description'] = await self.get_description()\n\n    except AmazonScraperException as e:\n        self.logger.error(f'Error while getting seller info details: {e}')\n    except Exception as e:\n        self.logger.error(\n            f'Unexpected error while getting seller info: {e}'\n        )\n\n    return seller\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_seller_name","title":"<code>get_seller_name(seller)</code>  <code>async</code>","text":"<p>Extracts the seller name from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>WebElement</code> <p>The seller element.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The seller name.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_seller_name(self, seller: WebElement) -&gt; str:\n    \"\"\"\n    Extracts the seller name from the seller's data.\n\n    Args:\n        seller (WebElement): The seller element.\n\n    Returns:\n        str: The seller name.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n    seller_name = ''\n    try:\n        seller_name = seller.find_element(\n            By.CSS_SELECTOR, 'a.a-size-small.a-link-normal'\n        ).get_attribute('innerHTML')\n    except Exception as e:\n        raise AmazonScraperException(\n            f'Error while getting seller name: {e}'\n        )\n\n    return seller_name.strip()\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_seller_url","title":"<code>get_seller_url(seller)</code>  <code>async</code>","text":"<p>Extracts the seller URL from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>WebElement</code> <p>The seller element.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The seller URL.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_seller_url(self, seller: WebElement) -&gt; str:\n    \"\"\"\n    Extracts the seller URL from the seller's data.\n\n    Args:\n        seller (WebElement): The seller element.\n\n    Returns:\n        str: The seller URL.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n    seller_url = ''\n    try:\n        seller_url = seller.find_element(\n            By.CSS_SELECTOR, 'a.a-size-small.a-link-normal'\n        ).get_attribute('href')\n    except Exception as e:\n        raise AmazonScraperException(\n            f'Error while getting seller url: {e}'\n        )\n\n    return seller_url\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/amazon/#kami_pricing_analytics.data_collector.strategies.web_scraping.AmazonScraper.get_sellers_list","title":"<code>get_sellers_list()</code>  <code>async</code>","text":"<p>Extracts the list of sellers from the product page.</p> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of dictionaries, each containing data about a seller.</p> <p>Raises:</p> Type Description <code>AmazonScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/amazon.py</code> <pre><code>async def get_sellers_list(self) -&gt; List[Dict]:\n    \"\"\"\n    Extracts the list of sellers from the product page.\n\n    Returns:\n        List[Dict]: A list of dictionaries, each containing data about a seller.\n\n    Raises:\n        AmazonScraperException: If an error occurs during extraction.\n    \"\"\"\n\n    sellers = []\n    try:\n        self.webdriver.get(str(self.product_url))\n        clickable_element = self.webdriver.find_element(\n            By.XPATH,\n            '//div[@class=\"a-section a-spacing-none daodi-content\"]//a[@class=\"a-link-normal\"]',\n        )\n        clickable_element.click()\n        WebDriverWait(self.webdriver, 10).until(\n            EC.visibility_of_element_located((By.ID, 'aod-offer-list'))\n        )\n        sellers_offers = self.webdriver.find_elements(\n            By.CSS_SELECTOR, '#aod-offer-list #aod-offer'\n        )\n        for seller_offer in sellers_offers:\n            seller = {\n                'product_url': self.product_url,\n                'marketplace_id': '',\n                'brand': '',\n                'description': '',\n                'price': '',\n                'seller_id': '',\n                'seller_name': '',\n                'seller_url': '',\n            }\n            seller['price'] = await self.get_price(seller_offer)\n            seller['seller_id'] = await self.get_seller_id(seller_offer)\n            seller['seller_name'] = await self.get_seller_name(\n                seller_offer\n            )\n            seller['seller_url'] = await self.get_seller_url(seller_offer)\n            sellers.append(seller)\n    except Exception as e:\n        raise AmazonScraperException(\n            f'Error while getting sellers list: {e}'\n        )\n\n    return sellers\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/","title":"Base Scraper","text":"<p>This document provides details about the base scraper functionality. Below is the auto-generated documentation for the <code>BaseScraper</code> class.</p> <p>BaseScraper </p> <p>               Bases: <code>BaseCollector</code>, <code>ABC</code></p> <p>Abstract base class for scraping strategies. Implements common functionalities for web scraping operations, including handling web drivers and HTTP clients with respect for robots.txt constraints.</p> <p>Attributes:</p> Name Type Description <code>user_agent</code> <code>str</code> <p>Default user agent for HTTP requests.</p> <code>http_client</code> <code>AsyncClient</code> <p>Async HTTP client for making requests.</p> <code>base_url</code> <code>str</code> <p>Base URL derived from the product URL.</p> <code>robots_url</code> <code>str</code> <p>URL to the robots.txt file.</p> <code>crawl_delay</code> <code>int</code> <p>Delay between requests as specified in robots.txt.</p> <code>logger_name</code> <code>str</code> <p>Name for the logger.</p> <code>logger</code> <code>Logger</code> <p>Logger instance for logging.</p> <code>webdriver</code> <code>WebDriver</code> <p>Selenium WebDriver instance.</p> <code>user_agents</code> <code>list</code> <p>List of user agents for requests.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>class BaseScraper(BaseCollector, ABC):\n    \"\"\"\n    Abstract base class for scraping strategies. Implements common functionalities\n    for web scraping operations, including handling web drivers and HTTP clients\n    with respect for robots.txt constraints.\n\n    Attributes:\n        user_agent (str): Default user agent for HTTP requests.\n        http_client (httpx.AsyncClient): Async HTTP client for making requests.\n        base_url (str): Base URL derived from the product URL.\n        robots_url (str): URL to the robots.txt file.\n        crawl_delay (int): Delay between requests as specified in robots.txt.\n        logger_name (str): Name for the logger.\n        logger (logging.Logger): Logger instance for logging.\n        webdriver (WebDriver): Selenium WebDriver instance.\n        user_agents (list): List of user agents for requests.\n    \"\"\"\n\n    user_agent: str = Field(default=DEFAULT_USER_AGENT)\n    http_client: httpx.AsyncClient = Field(default=None)\n    base_url: str = Field(default='')\n    robots_url: str = Field(default='')\n    crawl_delay: int = Field(default=DEFAULT_CRAWL_DELAY)\n    logger_name: str = Field(default='pricing-scraper')\n    logger: logging.Logger = Field(default=None)\n    webdriver: WebDriver = Field(default=None)\n    user_agents: list = USER_AGENTS\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def __init__(self, **data):\n        \"\"\"\n        Initializes the scraper with base URL settings and logger configuration.\n        \"\"\"\n        super().__init__(**data)\n        self.base_url = self.product_url.scheme + '://' + self.product_url.host\n        self.robots_url = f'{self.base_url}/robots.txt'\n        self._crawl_delay_fetched = False\n        self.set_logger(self.logger_name)\n\n    def _setup_driver(self) -&gt; WebDriver:\n        \"\"\"\n        Configures and returns a headless Selenium WebDriver with random user-agent.\n        Includes modifications to evade detection via `selenium_stealth`.\n        \"\"\"\n        options = Options()\n        options.add_argument('--headless')\n        options.add_argument('--no-sandbox')\n        options.add_argument('--disable-dev-shm-usage')\n\n        user_agent = random.choice(self.user_agents)\n        options.add_argument(f'user-agent={user_agent}')\n\n        driver = webdriver.Chrome(\n            service=Service(ChromeDriverManager().install()), options=options\n        )\n        stealth(\n            driver,\n            languages=['en-US', 'en'],\n            vendor='Google Inc.',\n            platform='Win32',\n            webgl_vendor='Intel Inc.',\n            renderer='Intel Iris OpenGL Engine',\n            fix_hairline=True,\n        )\n        return driver\n\n    async def set_webdriver(self) -&gt; WebDriver:\n        \"\"\"\n        Asynchronously sets up and assigns a WebDriver to this scraper instance.\n        Handles exceptions and logs them appropriately.\n        \"\"\"\n        try:\n            with ThreadPoolExecutor() as executor:\n                loop = asyncio.get_running_loop()\n                future = loop.run_in_executor(executor, self._setup_driver)\n                driver = await future\n                self.webdriver = driver\n        except Exception as e:\n            self.logger.exception(f'Error getting webdriver: {e}')\n\n    @asynccontextmanager\n    async def get_http_client(self):\n        \"\"\"\n        Context manager for HTTP client to ensure proper header setup and cleanup.\n        \"\"\"\n        headers = {'User-Agent': self.user_agent}\n        async with httpx.AsyncClient(headers=headers) as client:\n            yield client\n\n    async def _get_crawl_delay_async(self) -&gt; int:\n        rules = Robots()\n        try:\n            async with self.get_http_client() as client:\n                response = await client.get(self.robots_url)\n            rules.parse(response.text)\n            user_agent = DEFAULT_USER_AGENT\n            delay = rules.get_crawl_delay(user_agent)\n            return delay if delay is not None else DEFAULT_CRAWL_DELAY\n        except Exception as e:\n            self.logger.exception(f'Error getting crawl delay: {e}')\n            return DEFAULT_CRAWL_DELAY\n\n    async def _ensure_crawl_delay(self):\n        if not self._crawl_delay_fetched:\n            self.crawl_delay = await self._get_crawl_delay_async()\n            self._crawl_delay_fetched = True\n\n    def _get_base_url(self) -&gt; str:\n        parsed_url = urlparse(str(self.product_url))\n        return f'{parsed_url.scheme}://{parsed_url.netloc}'\n\n    def set_logger(self, logger_name: str):\n        self.logger = logging.getLogger(logger_name)\n\n    async def fetch_content(self, url: str = '') -&gt; str:\n        \"\"\"\n        Fetches content from the given URL using the configured HTTP client,\n        respecting the crawl delay defined in robots.txt.\n\n        Args:\n            url (str): URL to fetch. If empty, uses the product URL.\n\n        Returns:\n            str: The content of the page.\n        \"\"\"\n        await self._ensure_crawl_delay()\n        async with self.get_http_client() as client:\n            product_url = url if url else str(self.product_url)\n            response = await client.get(product_url)\n        return response.text\n\n    @abstractmethod\n    async def get_marketplace_id(self) -&gt; str:\n        \"\"\"\n        Abstract method to get the marketplace ID from the scraped content.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_brand(self) -&gt; str:\n        \"\"\"\n        Abstract method to get the brand from the scraped content.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_description(self) -&gt; str:\n        \"\"\"\n        Abstract method to get the description from the scraped content.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_price(self) -&gt; str:\n        \"\"\"\n        Abstract method to get the price from the scraped content.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_seller_id(self) -&gt; str:\n        \"\"\"\n        Abstract method to get the seller ID from the scraped content.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_seller_name(self) -&gt; str:\n        \"\"\"\n        Abstract method to get the seller name from the scraped content.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_seller_url(self) -&gt; str:\n        \"\"\"\n        Abstract method to get the seller URL from the scraped content.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_seller_info(self, seller) -&gt; dict:\n        \"\"\"\n        Abstract method to get the seller info from the scraped content.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_sellers_list(self) -&gt; list:\n        \"\"\"\n        Abstract method to get the sellers list from the scraped content.\n        \"\"\"\n        pass\n\n    async def scrap_product(self) -&gt; list:\n        \"\"\"\n        Orchestrates the scraping process. Initializes WebDriver, fetches sellers,\n        extracts their info, and ensures cleanup. Logs errors during the process.\n\n        Returns:\n            list: List of dictionaries, each containing seller info.\n        \"\"\"\n        try:\n            await self.set_webdriver()\n            sellers = await self.get_sellers_list()\n            sellers_list = []\n            for seller in sellers:\n                try:\n                    seller_info = await self.get_seller_info(seller)\n                    sellers_list.append(seller_info)\n                except Exception as e:\n                    self.logger.error(f'Error while getting seller info: {e}')\n            return sellers_list\n        except WebDriverException as wd_error:\n            self.logger.error(\n                f'Webdriver Error while scraping product: {wd_error}'\n            )\n        except Exception as e:\n            self.logger.error(f'Unexpected Error while scraping product: {e}')\n        finally:\n            if self.webdriver:\n                self.webdriver.quit()\n\n        return []\n\n    async def execute(self) -&gt; list:\n        \"\"\"\n        Executes the scraping process and returns the results.\n\n        Returns:\n            list: A list of scraped data.\n        \"\"\"\n        return await self.scrap_product()\n\n    async def close_http_client(self):\n        \"\"\"\n        Closes the HTTP client if it has been initialized.\n        \"\"\"\n        if self.http_client:\n            await self.http_client.aclose()\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.__init__","title":"<code>__init__(**data)</code>","text":"<p>Initializes the scraper with base URL settings and logger configuration.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>def __init__(self, **data):\n    \"\"\"\n    Initializes the scraper with base URL settings and logger configuration.\n    \"\"\"\n    super().__init__(**data)\n    self.base_url = self.product_url.scheme + '://' + self.product_url.host\n    self.robots_url = f'{self.base_url}/robots.txt'\n    self._crawl_delay_fetched = False\n    self.set_logger(self.logger_name)\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.close_http_client","title":"<code>close_http_client()</code>  <code>async</code>","text":"<p>Closes the HTTP client if it has been initialized.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>async def close_http_client(self):\n    \"\"\"\n    Closes the HTTP client if it has been initialized.\n    \"\"\"\n    if self.http_client:\n        await self.http_client.aclose()\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.execute","title":"<code>execute()</code>  <code>async</code>","text":"<p>Executes the scraping process and returns the results.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of scraped data.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>async def execute(self) -&gt; list:\n    \"\"\"\n    Executes the scraping process and returns the results.\n\n    Returns:\n        list: A list of scraped data.\n    \"\"\"\n    return await self.scrap_product()\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.fetch_content","title":"<code>fetch_content(url='')</code>  <code>async</code>","text":"<p>Fetches content from the given URL using the configured HTTP client, respecting the crawl delay defined in robots.txt.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch. If empty, uses the product URL.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The content of the page.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>async def fetch_content(self, url: str = '') -&gt; str:\n    \"\"\"\n    Fetches content from the given URL using the configured HTTP client,\n    respecting the crawl delay defined in robots.txt.\n\n    Args:\n        url (str): URL to fetch. If empty, uses the product URL.\n\n    Returns:\n        str: The content of the page.\n    \"\"\"\n    await self._ensure_crawl_delay()\n    async with self.get_http_client() as client:\n        product_url = url if url else str(self.product_url)\n        response = await client.get(product_url)\n    return response.text\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_brand","title":"<code>get_brand()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the brand from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_brand(self) -&gt; str:\n    \"\"\"\n    Abstract method to get the brand from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_description","title":"<code>get_description()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the description from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_description(self) -&gt; str:\n    \"\"\"\n    Abstract method to get the description from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_http_client","title":"<code>get_http_client()</code>  <code>async</code>","text":"<p>Context manager for HTTP client to ensure proper header setup and cleanup.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@asynccontextmanager\nasync def get_http_client(self):\n    \"\"\"\n    Context manager for HTTP client to ensure proper header setup and cleanup.\n    \"\"\"\n    headers = {'User-Agent': self.user_agent}\n    async with httpx.AsyncClient(headers=headers) as client:\n        yield client\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_marketplace_id","title":"<code>get_marketplace_id()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the marketplace ID from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_marketplace_id(self) -&gt; str:\n    \"\"\"\n    Abstract method to get the marketplace ID from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_price","title":"<code>get_price()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the price from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_price(self) -&gt; str:\n    \"\"\"\n    Abstract method to get the price from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_seller_id","title":"<code>get_seller_id()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the seller ID from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_seller_id(self) -&gt; str:\n    \"\"\"\n    Abstract method to get the seller ID from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_seller_info","title":"<code>get_seller_info(seller)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the seller info from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_seller_info(self, seller) -&gt; dict:\n    \"\"\"\n    Abstract method to get the seller info from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_seller_name","title":"<code>get_seller_name()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the seller name from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_seller_name(self) -&gt; str:\n    \"\"\"\n    Abstract method to get the seller name from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_seller_url","title":"<code>get_seller_url()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the seller URL from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_seller_url(self) -&gt; str:\n    \"\"\"\n    Abstract method to get the seller URL from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.get_sellers_list","title":"<code>get_sellers_list()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to get the sellers list from the scraped content.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>@abstractmethod\nasync def get_sellers_list(self) -&gt; list:\n    \"\"\"\n    Abstract method to get the sellers list from the scraped content.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.scrap_product","title":"<code>scrap_product()</code>  <code>async</code>","text":"<p>Orchestrates the scraping process. Initializes WebDriver, fetches sellers, extracts their info, and ensures cleanup. Logs errors during the process.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of dictionaries, each containing seller info.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>async def scrap_product(self) -&gt; list:\n    \"\"\"\n    Orchestrates the scraping process. Initializes WebDriver, fetches sellers,\n    extracts their info, and ensures cleanup. Logs errors during the process.\n\n    Returns:\n        list: List of dictionaries, each containing seller info.\n    \"\"\"\n    try:\n        await self.set_webdriver()\n        sellers = await self.get_sellers_list()\n        sellers_list = []\n        for seller in sellers:\n            try:\n                seller_info = await self.get_seller_info(seller)\n                sellers_list.append(seller_info)\n            except Exception as e:\n                self.logger.error(f'Error while getting seller info: {e}')\n        return sellers_list\n    except WebDriverException as wd_error:\n        self.logger.error(\n            f'Webdriver Error while scraping product: {wd_error}'\n        )\n    except Exception as e:\n        self.logger.error(f'Unexpected Error while scraping product: {e}')\n    finally:\n        if self.webdriver:\n            self.webdriver.quit()\n\n    return []\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/base-scraper/#kami_pricing_analytics.data_collector.strategies.web_scraping.BaseScraper.set_webdriver","title":"<code>set_webdriver()</code>  <code>async</code>","text":"<p>Asynchronously sets up and assigns a WebDriver to this scraper instance. Handles exceptions and logs them appropriately.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/base_scraper.py</code> <pre><code>async def set_webdriver(self) -&gt; WebDriver:\n    \"\"\"\n    Asynchronously sets up and assigns a WebDriver to this scraper instance.\n    Handles exceptions and logs them appropriately.\n    \"\"\"\n    try:\n        with ThreadPoolExecutor() as executor:\n            loop = asyncio.get_running_loop()\n            future = loop.run_in_executor(executor, self._setup_driver)\n            driver = await future\n            self.webdriver = driver\n    except Exception as e:\n        self.logger.exception(f'Error getting webdriver: {e}')\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/","title":"Beleza Na Web Scraper","text":"<p>This document provides details about the Beleza Na Web scraper functionality. Below is the auto-generated documentation for the <code>BelezaNaWebScraper</code> class.</p> <p>               Bases: <code>BaseScraper</code></p> <p>Scraper specifically designed for the 'Beleza Na Web' marketplace. It extracts seller information such as marketplace ID, brand, description, and pricing data from product pages.</p> Inherits from <p>BaseScraper (class): Abstract base class for scraping strategies.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>class BelezaNaWebScraper(BaseScraper):\n    \"\"\"\n    Scraper specifically designed for the 'Beleza Na Web' marketplace. It extracts seller\n    information such as marketplace ID, brand, description, and pricing data from product pages.\n\n    Inherits from:\n        BaseScraper (class): Abstract base class for scraping strategies.\n    \"\"\"\n\n    def __init__(self, **data):\n        \"\"\"\n        Initializes the scraper with a specific logger for 'Beleza Na Web'.\n        \"\"\"\n        super().__init__(**data, logger_name='beleza-na-web-scraper')\n\n    async def get_marketplace_id(self, seller) -&gt; str:\n        \"\"\"\n        Extracts the marketplace ID from the seller's data.\n\n        Args:\n            seller (dict): The seller information dictionary.\n\n        Returns:\n            str: The marketplace ID.\n\n        Raises:\n            BelezaNaWebScraperException: If an error occurs during extraction.\n        \"\"\"\n        try:\n            marketplace_id = seller['sku']\n            return marketplace_id\n        except Exception as e:\n            raise BelezaNaWebScraperException(\n                f'Error while getting marketplace ID: {e}'\n            )\n\n    async def get_brand(self, seller) -&gt; str:\n        \"\"\"\n        Extracts the brand from the seller's data.\n\n        Args:\n            seller (dict): The seller information dictionary.\n\n        Returns:\n            str: The brand.\n\n        Raises:\n            BelezaNaWebScraperException: If an error occurs during extraction.\n        \"\"\"\n        try:\n            brand = seller['brand']\n            return brand\n        except Exception as e:\n            raise BelezaNaWebScraperException(\n                f'Error while getting brand: {e}'\n            )\n\n    async def get_description(self, seller) -&gt; str:\n        \"\"\"\n        Extracts the description from the seller's data.\n\n        Args:\n            seller (dict): The seller information dictionary.\n\n        Returns:\n            str: The description.\n\n        Raises:\n            BelezaNaWebScraperException: If an error occurs during extraction.\n        \"\"\"\n        try:\n            description = seller['name']\n            return description\n        except Exception as e:\n            raise BelezaNaWebScraperException(\n                f'Error while getting description: {e}'\n            )\n\n    async def get_price(self, seller) -&gt; str:\n        \"\"\"\n        Extracts the price from the seller's data.\n\n        Args:\n            seller (dict): The seller information dictionary.\n\n        Returns:\n            str: The price.\n\n        Raises:\n            BelezaNaWebScraperException: If an error occurs during extraction.\n        \"\"\"\n        try:\n            price = seller['price']\n            return price\n        except Exception as e:\n            raise BelezaNaWebScraperException(\n                f'Error while getting price: {e}'\n            )\n\n    async def get_seller_id(self, seller) -&gt; str:\n        \"\"\"\n        Extracts the seller ID from the seller's data.\n\n        Args:\n            seller (dict): The seller information dictionary.\n\n        Returns:\n            str: The seller ID.\n\n        Raises:\n            BelezaNaWebScraperException: If an error occurs during extraction.\n        \"\"\"\n        try:\n            seller_id = seller['seller']['id']\n            return seller_id\n        except Exception as e:\n            raise BelezaNaWebScraperException(\n                f'Error while getting seller ID: {e}'\n            )\n\n    async def get_seller_name(self, seller) -&gt; str:\n        \"\"\"\n        Extracts the seller name from the seller's data.\n\n        Args:\n            seller (dict): The seller information dictionary.\n\n        Returns:\n            str: The seller name.\n\n        Raises:\n            BelezaNaWebScraperException: If an error occurs during extraction.\n        \"\"\"\n        try:\n            seller_name = seller['seller']['name']\n            return seller_name\n        except Exception as e:\n            raise BelezaNaWebScraperException(\n                f'Error while getting seller name: {e}'\n            )\n\n    async def get_seller_url(self) -&gt; str:\n        return ''\n\n    async def get_sellers_list(self) -&gt; List[Dict]:\n        \"\"\"\n        Retrieves a list of sellers from the product page by scraping specific HTML elements.\n\n        Returns:\n            list: A list of dictionaries, each containing data about a seller.\n\n        Raises:\n            BelezaNaWebScraperException: If an error occurs while scraping the sellers list.\n        \"\"\"\n        sellers = []\n        try:\n            self.webdriver.get(str(self.product_url))\n            id_sellers = self.webdriver.find_elements(\n                By.CSS_SELECTOR, 'a.js-add-to-cart'\n            )\n            for id_seller in id_sellers:\n                sellers_data = id_seller.get_attribute('data-sku')\n                row = json.loads(sellers_data)[0]\n                sellers.append(row)\n            return sellers\n        except WebDriverException as wd_error:\n            self.logger.error(\n                f'Webdriver Error while getting sellers list: {wd_error}'\n            )\n            raise BelezaNaWebScraperException(\n                f'Error while getting sellers list: {wd_error}'\n            )\n\n    async def get_seller_info(self, seller_info) -&gt; Dict:\n        \"\"\"\n        Compiles detailed information about a seller based on provided raw data.\n\n        Args:\n            seller_info (dict): Raw seller data from which to extract details.\n\n        Returns:\n            dict: A dictionary containing detailed seller information.\n\n        Raises:\n            BelezaNaWebScraperException: If an error occurs while compiling seller details.\n        \"\"\"\n        seller = {\n            'product_url': self.product_url,\n            'marketplace_id': '',\n            'brand': '',\n            'description': '',\n            'price': '',\n            'seller_id': '',\n            'seller_name': '',\n            'seller_url': '',\n        }\n\n        try:\n            seller['marketplace_id'] = await self.get_marketplace_id(\n                seller_info\n            )\n            seller['brand'] = await self.get_brand(seller_info)\n            seller['description'] = await self.get_description(seller_info)\n            seller['price'] = await self.get_price(seller_info)\n            seller['seller_id'] = await self.get_seller_id(seller_info)\n            seller['seller_name'] = await self.get_seller_name(seller_info)\n        except BelezaNaWebScraperException as e:\n            self.logger.error(f'Error while getting seller info details: {e}')\n            raise\n        except Exception as e:\n            self.logger.error(\n                f'Unexpected error while getting seller info: {e}'\n            )\n            raise BelezaNaWebScraperException(\n                f'Unexpected error while getting seller info: {e}'\n            )\n\n        return seller\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.__init__","title":"<code>__init__(**data)</code>","text":"<p>Initializes the scraper with a specific logger for 'Beleza Na Web'.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>def __init__(self, **data):\n    \"\"\"\n    Initializes the scraper with a specific logger for 'Beleza Na Web'.\n    \"\"\"\n    super().__init__(**data, logger_name='beleza-na-web-scraper')\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.get_brand","title":"<code>get_brand(seller)</code>  <code>async</code>","text":"<p>Extracts the brand from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>dict</code> <p>The seller information dictionary.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The brand.</p> <p>Raises:</p> Type Description <code>BelezaNaWebScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>async def get_brand(self, seller) -&gt; str:\n    \"\"\"\n    Extracts the brand from the seller's data.\n\n    Args:\n        seller (dict): The seller information dictionary.\n\n    Returns:\n        str: The brand.\n\n    Raises:\n        BelezaNaWebScraperException: If an error occurs during extraction.\n    \"\"\"\n    try:\n        brand = seller['brand']\n        return brand\n    except Exception as e:\n        raise BelezaNaWebScraperException(\n            f'Error while getting brand: {e}'\n        )\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.get_description","title":"<code>get_description(seller)</code>  <code>async</code>","text":"<p>Extracts the description from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>dict</code> <p>The seller information dictionary.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The description.</p> <p>Raises:</p> Type Description <code>BelezaNaWebScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>async def get_description(self, seller) -&gt; str:\n    \"\"\"\n    Extracts the description from the seller's data.\n\n    Args:\n        seller (dict): The seller information dictionary.\n\n    Returns:\n        str: The description.\n\n    Raises:\n        BelezaNaWebScraperException: If an error occurs during extraction.\n    \"\"\"\n    try:\n        description = seller['name']\n        return description\n    except Exception as e:\n        raise BelezaNaWebScraperException(\n            f'Error while getting description: {e}'\n        )\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.get_marketplace_id","title":"<code>get_marketplace_id(seller)</code>  <code>async</code>","text":"<p>Extracts the marketplace ID from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>dict</code> <p>The seller information dictionary.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The marketplace ID.</p> <p>Raises:</p> Type Description <code>BelezaNaWebScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>async def get_marketplace_id(self, seller) -&gt; str:\n    \"\"\"\n    Extracts the marketplace ID from the seller's data.\n\n    Args:\n        seller (dict): The seller information dictionary.\n\n    Returns:\n        str: The marketplace ID.\n\n    Raises:\n        BelezaNaWebScraperException: If an error occurs during extraction.\n    \"\"\"\n    try:\n        marketplace_id = seller['sku']\n        return marketplace_id\n    except Exception as e:\n        raise BelezaNaWebScraperException(\n            f'Error while getting marketplace ID: {e}'\n        )\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.get_price","title":"<code>get_price(seller)</code>  <code>async</code>","text":"<p>Extracts the price from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>dict</code> <p>The seller information dictionary.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The price.</p> <p>Raises:</p> Type Description <code>BelezaNaWebScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>async def get_price(self, seller) -&gt; str:\n    \"\"\"\n    Extracts the price from the seller's data.\n\n    Args:\n        seller (dict): The seller information dictionary.\n\n    Returns:\n        str: The price.\n\n    Raises:\n        BelezaNaWebScraperException: If an error occurs during extraction.\n    \"\"\"\n    try:\n        price = seller['price']\n        return price\n    except Exception as e:\n        raise BelezaNaWebScraperException(\n            f'Error while getting price: {e}'\n        )\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.get_seller_id","title":"<code>get_seller_id(seller)</code>  <code>async</code>","text":"<p>Extracts the seller ID from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>dict</code> <p>The seller information dictionary.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The seller ID.</p> <p>Raises:</p> Type Description <code>BelezaNaWebScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>async def get_seller_id(self, seller) -&gt; str:\n    \"\"\"\n    Extracts the seller ID from the seller's data.\n\n    Args:\n        seller (dict): The seller information dictionary.\n\n    Returns:\n        str: The seller ID.\n\n    Raises:\n        BelezaNaWebScraperException: If an error occurs during extraction.\n    \"\"\"\n    try:\n        seller_id = seller['seller']['id']\n        return seller_id\n    except Exception as e:\n        raise BelezaNaWebScraperException(\n            f'Error while getting seller ID: {e}'\n        )\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.get_seller_info","title":"<code>get_seller_info(seller_info)</code>  <code>async</code>","text":"<p>Compiles detailed information about a seller based on provided raw data.</p> <p>Parameters:</p> Name Type Description Default <code>seller_info</code> <code>dict</code> <p>Raw seller data from which to extract details.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>A dictionary containing detailed seller information.</p> <p>Raises:</p> Type Description <code>BelezaNaWebScraperException</code> <p>If an error occurs while compiling seller details.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>async def get_seller_info(self, seller_info) -&gt; Dict:\n    \"\"\"\n    Compiles detailed information about a seller based on provided raw data.\n\n    Args:\n        seller_info (dict): Raw seller data from which to extract details.\n\n    Returns:\n        dict: A dictionary containing detailed seller information.\n\n    Raises:\n        BelezaNaWebScraperException: If an error occurs while compiling seller details.\n    \"\"\"\n    seller = {\n        'product_url': self.product_url,\n        'marketplace_id': '',\n        'brand': '',\n        'description': '',\n        'price': '',\n        'seller_id': '',\n        'seller_name': '',\n        'seller_url': '',\n    }\n\n    try:\n        seller['marketplace_id'] = await self.get_marketplace_id(\n            seller_info\n        )\n        seller['brand'] = await self.get_brand(seller_info)\n        seller['description'] = await self.get_description(seller_info)\n        seller['price'] = await self.get_price(seller_info)\n        seller['seller_id'] = await self.get_seller_id(seller_info)\n        seller['seller_name'] = await self.get_seller_name(seller_info)\n    except BelezaNaWebScraperException as e:\n        self.logger.error(f'Error while getting seller info details: {e}')\n        raise\n    except Exception as e:\n        self.logger.error(\n            f'Unexpected error while getting seller info: {e}'\n        )\n        raise BelezaNaWebScraperException(\n            f'Unexpected error while getting seller info: {e}'\n        )\n\n    return seller\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.get_seller_name","title":"<code>get_seller_name(seller)</code>  <code>async</code>","text":"<p>Extracts the seller name from the seller's data.</p> <p>Parameters:</p> Name Type Description Default <code>seller</code> <code>dict</code> <p>The seller information dictionary.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The seller name.</p> <p>Raises:</p> Type Description <code>BelezaNaWebScraperException</code> <p>If an error occurs during extraction.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>async def get_seller_name(self, seller) -&gt; str:\n    \"\"\"\n    Extracts the seller name from the seller's data.\n\n    Args:\n        seller (dict): The seller information dictionary.\n\n    Returns:\n        str: The seller name.\n\n    Raises:\n        BelezaNaWebScraperException: If an error occurs during extraction.\n    \"\"\"\n    try:\n        seller_name = seller['seller']['name']\n        return seller_name\n    except Exception as e:\n        raise BelezaNaWebScraperException(\n            f'Error while getting seller name: {e}'\n        )\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/beleza-na-web/#kami_pricing_analytics.data_collector.strategies.web_scraping.BelezaNaWebScraper.get_sellers_list","title":"<code>get_sellers_list()</code>  <code>async</code>","text":"<p>Retrieves a list of sellers from the product page by scraping specific HTML elements.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>List[Dict]</code> <p>A list of dictionaries, each containing data about a seller.</p> <p>Raises:</p> Type Description <code>BelezaNaWebScraperException</code> <p>If an error occurs while scraping the sellers list.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/beleza_na_web.py</code> <pre><code>async def get_sellers_list(self) -&gt; List[Dict]:\n    \"\"\"\n    Retrieves a list of sellers from the product page by scraping specific HTML elements.\n\n    Returns:\n        list: A list of dictionaries, each containing data about a seller.\n\n    Raises:\n        BelezaNaWebScraperException: If an error occurs while scraping the sellers list.\n    \"\"\"\n    sellers = []\n    try:\n        self.webdriver.get(str(self.product_url))\n        id_sellers = self.webdriver.find_elements(\n            By.CSS_SELECTOR, 'a.js-add-to-cart'\n        )\n        for id_seller in id_sellers:\n            sellers_data = id_seller.get_attribute('data-sku')\n            row = json.loads(sellers_data)[0]\n            sellers.append(row)\n        return sellers\n    except WebDriverException as wd_error:\n        self.logger.error(\n            f'Webdriver Error while getting sellers list: {wd_error}'\n        )\n        raise BelezaNaWebScraperException(\n            f'Error while getting sellers list: {wd_error}'\n        )\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/","title":"Mercado Libre Scraper","text":"<p>This document provides details about the Mercado Libre scraper functionality. Below is the auto-generated documentation for the <code>MercadoLibreScraper</code> class.</p> <p>               Bases: <code>BaseScraper</code></p> <p>Scraper specifically designed for the Mercado Libre marketplace. It handles the intricacies of navigating and extracting data from Mercado Libre product pages.</p> <p>Attributes:</p> Name Type Description <code>search_url</code> <code>str</code> <p>Base URL used for constructing search queries.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>class MercadoLibreScraper(BaseScraper):\n    \"\"\"\n    Scraper specifically designed for the Mercado Libre marketplace. It handles the intricacies\n    of navigating and extracting data from Mercado Libre product pages.\n\n    Attributes:\n        search_url (str): Base URL used for constructing search queries.\n    \"\"\"\n\n    search_url: str = Field(default='https://lista.mercadolivre.com.br')\n\n    def __init__(self, **data):\n        \"\"\"\n        Initializes the scraper with Mercado Libre specific settings.\n        \"\"\"\n        super().__init__(\n            **data,\n            logger_name='mercado-libre-scraper',\n            user_agents=mlb_user_agents,\n        )\n\n    def _clean_product_description(self, product_description: str) -&gt; str:\n        \"\"\"\n        Cleans and normalizes the product description for consistent processing.\n\n        Args:\n            product_description (str): The raw product description.\n\n        Returns:\n            str: The cleaned product description.\n\n        Raises:\n            MercadoLibreScraperException: If an error occurs while cleaning the product description.\n        \"\"\"\n        try:\n            product_description = product_description.lower()\n            product_description = ''.join(\n                e for e in product_description if e.isalnum() or e.isspace()\n            )\n            product_description = ' '.join(product_description.split())\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while cleaning product description: {e}'\n            )\n\n        return product_description\n\n    def _build_product_search_url(self, product_description: str) -&gt; str:\n        \"\"\"\n        Constructs a search URL for a given product description.\n\n        Args:\n            product_description (str): The cleaned product description.\n\n        Returns:\n            str: The complete URL to perform a search on Mercado Libre.\n\n        Raises:\n            MercadoLibreScraperException: If an error occurs while building the search URL.\n        \"\"\"\n\n        try:\n            product_description = self._clean_product_description(\n                product_description\n            )\n            product_description = product_description.replace(' ', '-')\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while building product search URL: {e}'\n            )\n\n        return f'{self.search_url}/{product_description}'\n\n    async def get_marketplace_id(self, seller_url: str) -&gt; str:\n        \"\"\"\n        Extracts the marketplace ID from a seller URL.\n\n        Args:\n            seller_url (str): The URL of the seller's page.\n\n        Returns:\n            str: The extracted marketplace ID.\n\n        Raises:\n            MercadoLibreScraperException: If the marketplace ID cannot be extracted.\n        \"\"\"\n        marketplace_id = ''\n\n        try:\n            parsed_url = urlparse(seller_url)\n            query_params = parse_qs(parsed_url.query)\n            marketplace_id = query_params.get('item_id', [None])[0]\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting product ID: {e}'\n            )\n\n        return marketplace_id\n\n    async def get_brand(self) -&gt; str:\n        \"\"\"\n        Retrieves the brand of the product from the product page.\n\n        Returns:\n            str: The product brand.\n\n        Raises:\n            MercadoLibreScraperException: If the brand cannot be retrieved.\n        \"\"\"\n        brand = ''\n\n        try:\n            brand_xpath_expression = (\n                \"//span[contains(text(), 'Marca:')]/following-sibling::span\"\n            )\n            brand = self.webdriver.find_element(\n                By.XPATH, brand_xpath_expression\n            ).text.strip()\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting product brand: {e}'\n            )\n\n        return brand\n\n    async def get_description(self) -&gt; str:\n        \"\"\"\n        Retrieves the product description from the product page.\n\n        Returns:\n            str: The product description.\n\n        Raises:\n            MercadoLibreScraperException: If the description cannot be retrieved.\n        \"\"\"\n\n        description = ''\n\n        try:\n            description = self.webdriver.find_element(\n                By.CSS_SELECTOR, 'h1.ui-pdp-title'\n            ).text\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting product description: {e}'\n            )\n\n        return description\n\n    def _get_price_cents(self, price_container: WebElement) -&gt; str:\n        \"\"\"\n        Attempt to retrieve the cents part of the price from the price_container.\n\n        Args:\n            price_container (WebElement): The container element containing the price.\n\n        Returns:\n            str: The cents part of the price, if available.\n\n        Raises:\n            MercadoLibreScraperException: If the cents part of the price cannot be retrieved.\n        \"\"\"\n        price_cents = ''\n        try:\n            price_cents = price_container.find_element(\n                By.CSS_SELECTOR, 'span.andes-money-amount__cents'\n            ).text\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting price cents: {e}'\n            )\n        return price_cents\n\n    async def get_price(self) -&gt; str:\n        \"\"\"\n        Retrieves the product price from the product page.\n\n        Returns:\n            str: The product price.\n\n        Raises:\n            MercadoLibreScraperException: If the price cannot be retrieved.\n        \"\"\"\n        price = ''\n\n        try:\n            price_container = self.webdriver.find_element(\n                By.CSS_SELECTOR, 'span.andes-money-amount.ui-pdp-price__part'\n            )\n            currency_symbol = price_container.find_element(\n                By.CSS_SELECTOR, 'span.andes-money-amount__currency-symbol'\n            ).text\n            price_fraction = price_container.find_element(\n                By.CSS_SELECTOR, 'span.andes-money-amount__fraction'\n            ).text\n            price_cents = self._get_price_cents(price_container)\n\n            if price_cents:\n                price = f'{currency_symbol}{price_fraction},{price_cents}'\n            else:\n                price = f'{currency_symbol}{price_fraction}'\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting product price: {e}'\n            )\n\n        return price\n\n    async def get_seller_id(self, seller_url: str) -&gt; str:\n        \"\"\"\n        Extracts the seller ID from a seller URL.\n\n        Args:\n            seller_url (str): The URL of the seller's page.\n\n        Returns:\n            str: The extracted seller ID.\n\n        Raises:\n            MercadoLibreScraperException: If the seller ID cannot be extracted.\n        \"\"\"\n        seller_id = ''\n\n        try:\n            parsed_url = urlparse(seller_url)\n            query_params = parse_qs(parsed_url.query)\n            seller_id = query_params.get('seller_id', [None])[0]\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting seller ID: {e}'\n            )\n\n        return seller_id\n\n    async def get_seller_name(self) -&gt; str:\n        \"\"\"\n        Retrieves the seller name from the product page.\n\n        Returns:\n            str: The seller name.\n\n        Raises:\n            MercadoLibreScraperException: If the seller name cannot be retrieved.\n        \"\"\"\n        seller_name = ''\n\n        try:\n            seller_name_xpath_expression = (\n                \"//div[@class='ui-pdp-seller__header']/descendant::span[2]\"\n            )\n            seller_name = self.webdriver.find_element(\n                By.XPATH, seller_name_xpath_expression\n            ).text\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting seller name: {e}'\n            )\n\n        return seller_name\n\n    def _find_element_by_multiple_xpaths(self, xpaths: tuple) -&gt; WebElement:\n        \"\"\"Try to find an element using multiple XPaths, return the first successful one.\"\"\"\n        element = ()\n\n        try:\n            for xpath in xpaths:\n                try:\n                    element = self.webdriver.find_element(By.XPATH, xpath)\n                except NoSuchElementException:\n                    continue\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while finding element by multiple XPaths: {e}'\n            )\n        except NoSuchElementException as e:\n            raise MercadoLibreScraperException(\n                f'Element not found by multiple XPaths: {e}'\n            )\n\n        return element\n\n    async def get_seller_url(self) -&gt; str:\n        \"\"\"\n        Retrieves the seller URL from the product page.\n\n        Returns:\n            str: The seller URL.\n\n        Raises:\n            MercadoLibreScraperException: If the seller URL cannot be retrieved.\n        \"\"\"\n        seller_url = ''\n        seller_link_xpaths = (\n            \"//div[@id='seller_info']/descendant::a[1]\",\n            \"//div[@id='seller_data']/descendant::a[1]\",\n        )\n\n        try:\n            seller_link_element = self._find_element_by_multiple_xpaths(\n                seller_link_xpaths\n            )\n            seller_url = seller_link_element.get_attribute('href')\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting seller URL: {e}'\n            )\n\n        return seller_url\n\n    async def get_seller_info(self, seller_product_page: str) -&gt; Dict:\n        seller_url = ''\n\n        seller = {\n            'product_url': '',\n            'marketplace_id': '',\n            'brand': '',\n            'description': '',\n            'price': '',\n            'seller_id': '',\n            'seller_name': '',\n            'seller_url': '',\n        }\n\n        try:\n            self.webdriver.get(seller_product_page)\n            seller_url = await self.get_seller_url()\n            seller['product_url'] = seller_product_page\n            seller['marketplace_id'] = await self.get_marketplace_id(\n                seller_url\n            )\n            seller['brand'] = await self.get_brand()\n            seller['description'] = await self.get_description()\n            seller['price'] = await self.get_price()\n            seller['seller_id'] = await self.get_seller_id(seller_url)\n            seller['seller_name'] = await self.get_seller_name()\n            seller['seller_url'] = seller_url\n        except MercadoLibreScraperException as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting seller info details from {seller_product_page}: {e}'\n            )\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Unexpected Error while getting seller info from {seller_product_page}: {e}'\n            )\n\n        return seller\n\n    async def get_sellers_list(self) -&gt; List[str]:\n        \"\"\"\n        Retrieves the list of sellers for a given product URL.\n\n        Returns:\n            List: The list of sellers URLs.\n\n        Raises:\n            MercadoLibreScraperException: If the list of sellers cannot be retrieved.\n\n        \"\"\"\n        sellers = []\n\n        try:\n            self.webdriver.get(str(self.product_url))\n            product_description = self.webdriver.find_element(\n                By.CSS_SELECTOR, 'h1.ui-pdp-title'\n            ).text\n            product_search_url = self._build_product_search_url(\n                product_description\n            )\n            self.webdriver.get(product_search_url)\n            cleaned_description = set(\n                self._clean_product_description(product_description).split()\n            )\n            products_search_result_section = self.webdriver.find_element(\n                By.CSS_SELECTOR,\n                'section.ui-search-results.ui-search-results--without-disclaimer',\n            )\n\n            if products_search_result_section:\n                sellers_urls = products_search_result_section.find_elements(\n                    By.CSS_SELECTOR,\n                    'a.ui-search-item__group__element.ui-search-link__title-card.ui-search-link',\n                )\n                for seller_link in sellers_urls:\n                    title = (\n                        seller_link.get_attribute('title')\n                        if seller_link.get_attribute('title')\n                        else ''\n                    )\n                    cleaned_title = set(\n                        self._clean_product_description(title).split()\n                    )\n                    if cleaned_title == cleaned_description:\n                        sellers.append(seller_link.get_attribute('href'))\n        except Exception as e:\n            raise MercadoLibreScraperException(\n                f'Error while getting sellers list: {e}'\n            )\n\n        return sellers\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.__init__","title":"<code>__init__(**data)</code>","text":"<p>Initializes the scraper with Mercado Libre specific settings.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>def __init__(self, **data):\n    \"\"\"\n    Initializes the scraper with Mercado Libre specific settings.\n    \"\"\"\n    super().__init__(\n        **data,\n        logger_name='mercado-libre-scraper',\n        user_agents=mlb_user_agents,\n    )\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.get_brand","title":"<code>get_brand()</code>  <code>async</code>","text":"<p>Retrieves the brand of the product from the product page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The product brand.</p> <p>Raises:</p> Type Description <code>MercadoLibreScraperException</code> <p>If the brand cannot be retrieved.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>async def get_brand(self) -&gt; str:\n    \"\"\"\n    Retrieves the brand of the product from the product page.\n\n    Returns:\n        str: The product brand.\n\n    Raises:\n        MercadoLibreScraperException: If the brand cannot be retrieved.\n    \"\"\"\n    brand = ''\n\n    try:\n        brand_xpath_expression = (\n            \"//span[contains(text(), 'Marca:')]/following-sibling::span\"\n        )\n        brand = self.webdriver.find_element(\n            By.XPATH, brand_xpath_expression\n        ).text.strip()\n    except Exception as e:\n        raise MercadoLibreScraperException(\n            f'Error while getting product brand: {e}'\n        )\n\n    return brand\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.get_description","title":"<code>get_description()</code>  <code>async</code>","text":"<p>Retrieves the product description from the product page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The product description.</p> <p>Raises:</p> Type Description <code>MercadoLibreScraperException</code> <p>If the description cannot be retrieved.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>async def get_description(self) -&gt; str:\n    \"\"\"\n    Retrieves the product description from the product page.\n\n    Returns:\n        str: The product description.\n\n    Raises:\n        MercadoLibreScraperException: If the description cannot be retrieved.\n    \"\"\"\n\n    description = ''\n\n    try:\n        description = self.webdriver.find_element(\n            By.CSS_SELECTOR, 'h1.ui-pdp-title'\n        ).text\n    except Exception as e:\n        raise MercadoLibreScraperException(\n            f'Error while getting product description: {e}'\n        )\n\n    return description\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.get_marketplace_id","title":"<code>get_marketplace_id(seller_url)</code>  <code>async</code>","text":"<p>Extracts the marketplace ID from a seller URL.</p> <p>Parameters:</p> Name Type Description Default <code>seller_url</code> <code>str</code> <p>The URL of the seller's page.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted marketplace ID.</p> <p>Raises:</p> Type Description <code>MercadoLibreScraperException</code> <p>If the marketplace ID cannot be extracted.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>async def get_marketplace_id(self, seller_url: str) -&gt; str:\n    \"\"\"\n    Extracts the marketplace ID from a seller URL.\n\n    Args:\n        seller_url (str): The URL of the seller's page.\n\n    Returns:\n        str: The extracted marketplace ID.\n\n    Raises:\n        MercadoLibreScraperException: If the marketplace ID cannot be extracted.\n    \"\"\"\n    marketplace_id = ''\n\n    try:\n        parsed_url = urlparse(seller_url)\n        query_params = parse_qs(parsed_url.query)\n        marketplace_id = query_params.get('item_id', [None])[0]\n    except Exception as e:\n        raise MercadoLibreScraperException(\n            f'Error while getting product ID: {e}'\n        )\n\n    return marketplace_id\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.get_price","title":"<code>get_price()</code>  <code>async</code>","text":"<p>Retrieves the product price from the product page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The product price.</p> <p>Raises:</p> Type Description <code>MercadoLibreScraperException</code> <p>If the price cannot be retrieved.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>async def get_price(self) -&gt; str:\n    \"\"\"\n    Retrieves the product price from the product page.\n\n    Returns:\n        str: The product price.\n\n    Raises:\n        MercadoLibreScraperException: If the price cannot be retrieved.\n    \"\"\"\n    price = ''\n\n    try:\n        price_container = self.webdriver.find_element(\n            By.CSS_SELECTOR, 'span.andes-money-amount.ui-pdp-price__part'\n        )\n        currency_symbol = price_container.find_element(\n            By.CSS_SELECTOR, 'span.andes-money-amount__currency-symbol'\n        ).text\n        price_fraction = price_container.find_element(\n            By.CSS_SELECTOR, 'span.andes-money-amount__fraction'\n        ).text\n        price_cents = self._get_price_cents(price_container)\n\n        if price_cents:\n            price = f'{currency_symbol}{price_fraction},{price_cents}'\n        else:\n            price = f'{currency_symbol}{price_fraction}'\n    except Exception as e:\n        raise MercadoLibreScraperException(\n            f'Error while getting product price: {e}'\n        )\n\n    return price\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.get_seller_id","title":"<code>get_seller_id(seller_url)</code>  <code>async</code>","text":"<p>Extracts the seller ID from a seller URL.</p> <p>Parameters:</p> Name Type Description Default <code>seller_url</code> <code>str</code> <p>The URL of the seller's page.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted seller ID.</p> <p>Raises:</p> Type Description <code>MercadoLibreScraperException</code> <p>If the seller ID cannot be extracted.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>async def get_seller_id(self, seller_url: str) -&gt; str:\n    \"\"\"\n    Extracts the seller ID from a seller URL.\n\n    Args:\n        seller_url (str): The URL of the seller's page.\n\n    Returns:\n        str: The extracted seller ID.\n\n    Raises:\n        MercadoLibreScraperException: If the seller ID cannot be extracted.\n    \"\"\"\n    seller_id = ''\n\n    try:\n        parsed_url = urlparse(seller_url)\n        query_params = parse_qs(parsed_url.query)\n        seller_id = query_params.get('seller_id', [None])[0]\n    except Exception as e:\n        raise MercadoLibreScraperException(\n            f'Error while getting seller ID: {e}'\n        )\n\n    return seller_id\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.get_seller_name","title":"<code>get_seller_name()</code>  <code>async</code>","text":"<p>Retrieves the seller name from the product page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The seller name.</p> <p>Raises:</p> Type Description <code>MercadoLibreScraperException</code> <p>If the seller name cannot be retrieved.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>async def get_seller_name(self) -&gt; str:\n    \"\"\"\n    Retrieves the seller name from the product page.\n\n    Returns:\n        str: The seller name.\n\n    Raises:\n        MercadoLibreScraperException: If the seller name cannot be retrieved.\n    \"\"\"\n    seller_name = ''\n\n    try:\n        seller_name_xpath_expression = (\n            \"//div[@class='ui-pdp-seller__header']/descendant::span[2]\"\n        )\n        seller_name = self.webdriver.find_element(\n            By.XPATH, seller_name_xpath_expression\n        ).text\n    except Exception as e:\n        raise MercadoLibreScraperException(\n            f'Error while getting seller name: {e}'\n        )\n\n    return seller_name\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.get_seller_url","title":"<code>get_seller_url()</code>  <code>async</code>","text":"<p>Retrieves the seller URL from the product page.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The seller URL.</p> <p>Raises:</p> Type Description <code>MercadoLibreScraperException</code> <p>If the seller URL cannot be retrieved.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>async def get_seller_url(self) -&gt; str:\n    \"\"\"\n    Retrieves the seller URL from the product page.\n\n    Returns:\n        str: The seller URL.\n\n    Raises:\n        MercadoLibreScraperException: If the seller URL cannot be retrieved.\n    \"\"\"\n    seller_url = ''\n    seller_link_xpaths = (\n        \"//div[@id='seller_info']/descendant::a[1]\",\n        \"//div[@id='seller_data']/descendant::a[1]\",\n    )\n\n    try:\n        seller_link_element = self._find_element_by_multiple_xpaths(\n            seller_link_xpaths\n        )\n        seller_url = seller_link_element.get_attribute('href')\n    except Exception as e:\n        raise MercadoLibreScraperException(\n            f'Error while getting seller URL: {e}'\n        )\n\n    return seller_url\n</code></pre>"},{"location":"data_collector/strategies/web_scraping/mercado_libre/#kami_pricing_analytics.data_collector.strategies.web_scraping.MercadoLibreScraper.get_sellers_list","title":"<code>get_sellers_list()</code>  <code>async</code>","text":"<p>Retrieves the list of sellers for a given product URL.</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List[str]</code> <p>The list of sellers URLs.</p> <p>Raises:</p> Type Description <code>MercadoLibreScraperException</code> <p>If the list of sellers cannot be retrieved.</p> Source code in <code>kami_pricing_analytics/data_collector/strategies/web_scraping/mercado_libre.py</code> <pre><code>async def get_sellers_list(self) -&gt; List[str]:\n    \"\"\"\n    Retrieves the list of sellers for a given product URL.\n\n    Returns:\n        List: The list of sellers URLs.\n\n    Raises:\n        MercadoLibreScraperException: If the list of sellers cannot be retrieved.\n\n    \"\"\"\n    sellers = []\n\n    try:\n        self.webdriver.get(str(self.product_url))\n        product_description = self.webdriver.find_element(\n            By.CSS_SELECTOR, 'h1.ui-pdp-title'\n        ).text\n        product_search_url = self._build_product_search_url(\n            product_description\n        )\n        self.webdriver.get(product_search_url)\n        cleaned_description = set(\n            self._clean_product_description(product_description).split()\n        )\n        products_search_result_section = self.webdriver.find_element(\n            By.CSS_SELECTOR,\n            'section.ui-search-results.ui-search-results--without-disclaimer',\n        )\n\n        if products_search_result_section:\n            sellers_urls = products_search_result_section.find_elements(\n                By.CSS_SELECTOR,\n                'a.ui-search-item__group__element.ui-search-link__title-card.ui-search-link',\n            )\n            for seller_link in sellers_urls:\n                title = (\n                    seller_link.get_attribute('title')\n                    if seller_link.get_attribute('title')\n                    else ''\n                )\n                cleaned_title = set(\n                    self._clean_product_description(title).split()\n                )\n                if cleaned_title == cleaned_description:\n                    sellers.append(seller_link.get_attribute('href'))\n    except Exception as e:\n        raise MercadoLibreScraperException(\n            f'Error while getting sellers list: {e}'\n        )\n\n    return sellers\n</code></pre>"},{"location":"data_storage/base-storage/","title":"Storage","text":"<p>This document provides details about the basics functionality for a successfull data storage. Below is the auto-generated documentation for the <code>BaseStorage</code> and <code>StorageModeOptions</code> classes.</p> <p>BaseStorage </p> <p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Abstract base class for storage operations, providing a template for CRUD operations that all storage implementations must support. This ensures a uniform interface for storage interactions across different backends.</p> <p>Methods:</p> Name Description <code>save</code> <p>Asynchronously saves data to the storage.</p> <code>retrieve</code> <p>Asynchronously retrieves data from the storage based on specified criteria.</p> <code>update</code> <p>Asynchronously updates data in the storage that matches the specified criteria.</p> <code>delete</code> <p>Asynchronously deletes data from the storage that matches the specified criteria.</p> Source code in <code>kami_pricing_analytics/data_storage/base_storage.py</code> <pre><code>class BaseStorage(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for storage operations, providing a template for CRUD operations that all storage implementations must support. This ensures a uniform interface for storage interactions across different backends.\n\n    Methods:\n        save(Dict[str, Any]) -&gt; Any: Asynchronously saves data to the storage.\n        retrieve(Dict[str, Any]) -&gt; Any: Asynchronously retrieves data from the storage based on specified criteria.\n        update(Dict[str, Any], Dict[str, Any]) -&gt; Any: Asynchronously updates data in the storage that matches the specified criteria.\n        delete(Dict[str, Any]) -&gt; Any: Asynchronously deletes data from the storage that matches the specified criteria.\n    \"\"\"\n\n    @abstractmethod\n    async def save(self, data: Dict[str, Any]) -&gt; Any:\n        \"\"\"\n        Abstract method to save data to the storage system.\n\n        Args:\n            data (Dict[str, Any]): The data to be saved.\n\n        Returns:\n            Any: The result of the save operation, potentially including details such as an identifier or the saved item itself.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def retrieve(self, criteria: Dict[str, Any]) -&gt; Any:\n        \"\"\"\n        Abstract method to retrieve data from the storage system based on specified criteria.\n\n        Args:\n            criteria (Dict[str, Any]): The criteria used to filter the retrieval.\n\n        Returns:\n            Any: The data retrieved from the storage system.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def update(\n        self, criteria: Dict[str, Any], data: Dict[str, Any]\n    ) -&gt; Any:\n        \"\"\"\n        Abstract method to update data in the storage system that matches the specified criteria.\n\n        Args:\n            criteria (Dict[str, Any]): The criteria for selecting which data to update.\n            data (Dict[str, Any]): The new data to be updated.\n\n        Returns:\n            Any: The result of the update operation.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def delete(self, criteria: Dict[str, Any]) -&gt; Any:\n        \"\"\"\n        Abstract method to delete data from the storage system that matches the specified criteria.\n\n        Args:\n            criteria (Dict[str, Any]): The criteria for selecting which data to delete.\n\n        Returns:\n            Any: The result of the delete operation.\n        \"\"\"\n        pass\n</code></pre> <p>StorageModeOptions </p> <p>               Bases: <code>Enum</code></p> <p>Enumeration of supported storage modes.</p> <p>Attributes:</p> Name Type Description <code>SQLITE</code> <code>int</code> <p>SQLite database mode.</p> <code>POSTGRESQL</code> <code>int</code> <p>PostgreSQL database mode.</p> <code>MYSQL</code> <code>int</code> <p>MySQL database mode.</p> <code>SQLSERVER</code> <code>int</code> <p>SQL Server database mode.</p> <code>PLSQL</code> <code>int</code> <p>PL/SQL database mode.</p> Source code in <code>kami_pricing_analytics/data_storage/base_storage.py</code> <pre><code>class StorageModeOptions(Enum):\n    \"\"\"\n    Enumeration of supported storage modes.\n\n    Attributes:\n        SQLITE (int): SQLite database mode.\n        POSTGRESQL (int): PostgreSQL database mode.\n        MYSQL (int): MySQL database mode.\n        SQLSERVER (int): SQL Server database mode.\n        PLSQL (int): PL/SQL database mode.\n    \"\"\"\n\n    SQLITE = 0\n    POSTGRESQL = 1\n    MYSQL = 2\n    SQLSERVER = 3\n    PLSQL = 4\n</code></pre>"},{"location":"data_storage/base-storage/#kami_pricing_analytics.data_storage.BaseStorage.delete","title":"<code>delete(criteria)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to delete data from the storage system that matches the specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <code>Dict[str, Any]</code> <p>The criteria for selecting which data to delete.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the delete operation.</p> Source code in <code>kami_pricing_analytics/data_storage/base_storage.py</code> <pre><code>@abstractmethod\nasync def delete(self, criteria: Dict[str, Any]) -&gt; Any:\n    \"\"\"\n    Abstract method to delete data from the storage system that matches the specified criteria.\n\n    Args:\n        criteria (Dict[str, Any]): The criteria for selecting which data to delete.\n\n    Returns:\n        Any: The result of the delete operation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_storage/base-storage/#kami_pricing_analytics.data_storage.BaseStorage.retrieve","title":"<code>retrieve(criteria)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to retrieve data from the storage system based on specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <code>Dict[str, Any]</code> <p>The criteria used to filter the retrieval.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The data retrieved from the storage system.</p> Source code in <code>kami_pricing_analytics/data_storage/base_storage.py</code> <pre><code>@abstractmethod\nasync def retrieve(self, criteria: Dict[str, Any]) -&gt; Any:\n    \"\"\"\n    Abstract method to retrieve data from the storage system based on specified criteria.\n\n    Args:\n        criteria (Dict[str, Any]): The criteria used to filter the retrieval.\n\n    Returns:\n        Any: The data retrieved from the storage system.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_storage/base-storage/#kami_pricing_analytics.data_storage.BaseStorage.save","title":"<code>save(data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to save data to the storage system.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data to be saved.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the save operation, potentially including details such as an identifier or the saved item itself.</p> Source code in <code>kami_pricing_analytics/data_storage/base_storage.py</code> <pre><code>@abstractmethod\nasync def save(self, data: Dict[str, Any]) -&gt; Any:\n    \"\"\"\n    Abstract method to save data to the storage system.\n\n    Args:\n        data (Dict[str, Any]): The data to be saved.\n\n    Returns:\n        Any: The result of the save operation, potentially including details such as an identifier or the saved item itself.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_storage/base-storage/#kami_pricing_analytics.data_storage.BaseStorage.update","title":"<code>update(criteria, data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abstract method to update data in the storage system that matches the specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <code>Dict[str, Any]</code> <p>The criteria for selecting which data to update.</p> required <code>data</code> <code>Dict[str, Any]</code> <p>The new data to be updated.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the update operation.</p> Source code in <code>kami_pricing_analytics/data_storage/base_storage.py</code> <pre><code>@abstractmethod\nasync def update(\n    self, criteria: Dict[str, Any], data: Dict[str, Any]\n) -&gt; Any:\n    \"\"\"\n    Abstract method to update data in the storage system that matches the specified criteria.\n\n    Args:\n        criteria (Dict[str, Any]): The criteria for selecting which data to update.\n        data (Dict[str, Any]): The new data to be updated.\n\n    Returns:\n        Any: The result of the update operation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"data_storage/storage-factory/","title":"Storage Factory","text":"<p>This document provides details about Storage Factory functionality. Below is the auto-generated documentation for the <code>StorageFactory</code> and <code>DatabaseSettingsFactory</code> class.</p> <p>StorageFactory </p> <p>Factory class for managing storage instances across different database technologies.</p> <p>Attributes:</p> Name Type Description <code>storage_mapping</code> <code>Dict[StorageModeOptions, Type[BaseStorage]]</code> <p>Maps storage modes to corresponding storage classes.</p> <code>settings_mapping</code> <code>Dict[StorageModeOptions, Type[DatabaseSettings]]</code> <p>Maps storage modes to corresponding settings classes.</p> Source code in <code>kami_pricing_analytics/data_storage/storage_factory.py</code> <pre><code>class StorageFactory:\n    \"\"\"\n    Factory class for managing storage instances across different database technologies.\n\n    Attributes:\n        storage_mapping (Dict[StorageModeOptions, Type[BaseStorage]]): Maps storage modes to corresponding storage classes.\n        settings_mapping (Dict[StorageModeOptions, Type[DatabaseSettings]]): Maps storage modes to corresponding settings classes.\n    \"\"\"\n\n    storage_mapping: Dict[StorageModeOptions, Type[BaseStorage]] = {}\n    settings_mapping: Dict[StorageModeOptions, Type[DatabaseSettings]] = {}\n\n    @classmethod\n    def register_mode(\n        cls,\n        mode: StorageModeOptions,\n        storage: Type[BaseStorage],\n        settings: Type[DatabaseSettings],\n    ) -&gt; bool:\n        \"\"\"\n        Registers a storage mode with its corresponding storage and settings classes.\n\n        Args:\n            mode (StorageModeOptions): The storage mode identifier.\n            storage (Type[BaseStorage]): The storage class.\n            settings (Type[DatabaseSettings]): The settings class.\n\n        Returns:\n            bool: True if the storage mode was successfully registered, False otherwise.\n\n        Raises:\n            ValueError: If an error occurs while registering the storage mode.\n        \"\"\"\n\n        is_registered = False\n        try:\n            cls.storage_mapping[mode] = storage\n            cls.settings_mapping[mode] = settings\n            is_registered = True\n        except Exception as e:\n            raise ValueError(f'Error while registering storage mode: {e}')\n\n        return is_registered\n\n    @classmethod\n    def get_mode(cls, mode: int) -&gt; Type[BaseStorage]:\n        \"\"\"\n        Retrieves a storage instance configured with appropriate settings for the specified mode.\n\n        Args:\n            mode (int): The storage mode identifier.\n\n        Returns:\n            Type[BaseStorage]: An instance of the corresponding storage class.\n        \"\"\"\n        storage_mode = Type[BaseStorage]\n        try:\n            storage_mode_option = StorageModeOptions(mode)\n            if (\n                storage_mode_option not in cls.storage_mapping\n                and storage_mode_option not in cls.settings_mapping\n            ):\n                raise ValueError(\n                    f'Unsupported STORAGE_MODE: {mode}. Available options: {storage_options}'\n                )\n            settings_class = cls.settings_mapping.get(storage_mode_option)\n            settings = settings_class()\n            storage_class = cls.storage_mapping.get(storage_mode_option)\n            storage_mode = storage_class(settings=settings)\n        except Exception as e:\n            raise ValueError(f'Error while retrieving storage mode: {e}')\n\n        return storage_mode\n</code></pre> <p>DatabaseSettingsFactory </p> <p>Factory class for managing database settings instances specific to storage modes.</p> <p>Attributes:</p> Name Type Description <code>settings_mapping</code> <code>Dict[StorageModeOptions, Type[DatabaseSettings]]</code> <p>Maps storage modes to corresponding settings classes.</p> Source code in <code>kami_pricing_analytics/data_storage/storage_factory.py</code> <pre><code>class DatabaseSettingsFactory:\n    \"\"\"\n    Factory class for managing database settings instances specific to storage modes.\n\n    Attributes:\n        settings_mapping (Dict[StorageModeOptions, Type[DatabaseSettings]]): Maps storage modes to corresponding settings classes.\n    \"\"\"\n\n    settings_mapping: Dict[StorageModeOptions, Type[DatabaseSettings]] = {}\n\n    @classmethod\n    def register_settings(\n        cls, mode: int, settings: Type[DatabaseSettings]\n    ) -&gt; bool:\n        \"\"\"\n        Registers database settings for a specific storage mode.\n\n        Args:\n            mode (int): The database mode identifier.\n            settings (Type[DatabaseSettings]): The settings class.\n\n        Returns:\n            bool: True if the database settings were successfully registered, False otherwise.\n\n        Raises:\n            ValueError: If an error occurs while registering the database settings.\n        \"\"\"\n\n        is_registered = False\n        if StorageModeOptions(mode) not in StorageModeOptions:\n            raise ValueError(\n                f'Unsupported Database Settings: {mode}. Available options: {storage_options}'\n            )\n\n        try:\n            cls.settings_mapping[StorageModeOptions(mode)] = settings\n            is_registered = True\n        except Exception as e:\n            raise ValueError(f'Error while registering database settings: {e}')\n\n        return is_registered\n\n    @classmethod\n    def get_settings(cls, mode: int) -&gt; Type[DatabaseSettings]:\n        \"\"\"\n        Retrieves the settings instance for the specified database mode.\n\n        Args:\n            mode (int): The database mode identifier.\n\n        Returns:\n            Type[DatabaseSettings]: An instance of the corresponding settings class.\n\n        Raises:\n            ValueError: If an error occurs while retrieving the database settings.\n        \"\"\"\n        try:\n            settings = cls.settings_mapping.get(StorageModeOptions(mode))\n        except Exception as e:\n            raise ValueError(f'Error while retrieving database settings: {e}')\n\n        if settings is None:\n            raise ValueError(\n                f'Unsupported Database Settings: {mode}. Available options: {storage_options}'\n            )\n        return settings\n</code></pre>"},{"location":"data_storage/storage-factory/#kami_pricing_analytics.data_storage.StorageFactory.get_mode","title":"<code>get_mode(mode)</code>  <code>classmethod</code>","text":"<p>Retrieves a storage instance configured with appropriate settings for the specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The storage mode identifier.</p> required <p>Returns:</p> Type Description <code>Type[BaseStorage]</code> <p>Type[BaseStorage]: An instance of the corresponding storage class.</p> Source code in <code>kami_pricing_analytics/data_storage/storage_factory.py</code> <pre><code>@classmethod\ndef get_mode(cls, mode: int) -&gt; Type[BaseStorage]:\n    \"\"\"\n    Retrieves a storage instance configured with appropriate settings for the specified mode.\n\n    Args:\n        mode (int): The storage mode identifier.\n\n    Returns:\n        Type[BaseStorage]: An instance of the corresponding storage class.\n    \"\"\"\n    storage_mode = Type[BaseStorage]\n    try:\n        storage_mode_option = StorageModeOptions(mode)\n        if (\n            storage_mode_option not in cls.storage_mapping\n            and storage_mode_option not in cls.settings_mapping\n        ):\n            raise ValueError(\n                f'Unsupported STORAGE_MODE: {mode}. Available options: {storage_options}'\n            )\n        settings_class = cls.settings_mapping.get(storage_mode_option)\n        settings = settings_class()\n        storage_class = cls.storage_mapping.get(storage_mode_option)\n        storage_mode = storage_class(settings=settings)\n    except Exception as e:\n        raise ValueError(f'Error while retrieving storage mode: {e}')\n\n    return storage_mode\n</code></pre>"},{"location":"data_storage/storage-factory/#kami_pricing_analytics.data_storage.StorageFactory.register_mode","title":"<code>register_mode(mode, storage, settings)</code>  <code>classmethod</code>","text":"<p>Registers a storage mode with its corresponding storage and settings classes.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>StorageModeOptions</code> <p>The storage mode identifier.</p> required <code>storage</code> <code>Type[BaseStorage]</code> <p>The storage class.</p> required <code>settings</code> <code>Type[DatabaseSettings]</code> <p>The settings class.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the storage mode was successfully registered, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs while registering the storage mode.</p> Source code in <code>kami_pricing_analytics/data_storage/storage_factory.py</code> <pre><code>@classmethod\ndef register_mode(\n    cls,\n    mode: StorageModeOptions,\n    storage: Type[BaseStorage],\n    settings: Type[DatabaseSettings],\n) -&gt; bool:\n    \"\"\"\n    Registers a storage mode with its corresponding storage and settings classes.\n\n    Args:\n        mode (StorageModeOptions): The storage mode identifier.\n        storage (Type[BaseStorage]): The storage class.\n        settings (Type[DatabaseSettings]): The settings class.\n\n    Returns:\n        bool: True if the storage mode was successfully registered, False otherwise.\n\n    Raises:\n        ValueError: If an error occurs while registering the storage mode.\n    \"\"\"\n\n    is_registered = False\n    try:\n        cls.storage_mapping[mode] = storage\n        cls.settings_mapping[mode] = settings\n        is_registered = True\n    except Exception as e:\n        raise ValueError(f'Error while registering storage mode: {e}')\n\n    return is_registered\n</code></pre>"},{"location":"data_storage/storage-factory/#kami_pricing_analytics.data_storage.DatabaseSettingsFactory.get_settings","title":"<code>get_settings(mode)</code>  <code>classmethod</code>","text":"<p>Retrieves the settings instance for the specified database mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The database mode identifier.</p> required <p>Returns:</p> Type Description <code>Type[DatabaseSettings]</code> <p>Type[DatabaseSettings]: An instance of the corresponding settings class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs while retrieving the database settings.</p> Source code in <code>kami_pricing_analytics/data_storage/storage_factory.py</code> <pre><code>@classmethod\ndef get_settings(cls, mode: int) -&gt; Type[DatabaseSettings]:\n    \"\"\"\n    Retrieves the settings instance for the specified database mode.\n\n    Args:\n        mode (int): The database mode identifier.\n\n    Returns:\n        Type[DatabaseSettings]: An instance of the corresponding settings class.\n\n    Raises:\n        ValueError: If an error occurs while retrieving the database settings.\n    \"\"\"\n    try:\n        settings = cls.settings_mapping.get(StorageModeOptions(mode))\n    except Exception as e:\n        raise ValueError(f'Error while retrieving database settings: {e}')\n\n    if settings is None:\n        raise ValueError(\n            f'Unsupported Database Settings: {mode}. Available options: {storage_options}'\n        )\n    return settings\n</code></pre>"},{"location":"data_storage/storage-factory/#kami_pricing_analytics.data_storage.DatabaseSettingsFactory.register_settings","title":"<code>register_settings(mode, settings)</code>  <code>classmethod</code>","text":"<p>Registers database settings for a specific storage mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The database mode identifier.</p> required <code>settings</code> <code>Type[DatabaseSettings]</code> <p>The settings class.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the database settings were successfully registered, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs while registering the database settings.</p> Source code in <code>kami_pricing_analytics/data_storage/storage_factory.py</code> <pre><code>@classmethod\ndef register_settings(\n    cls, mode: int, settings: Type[DatabaseSettings]\n) -&gt; bool:\n    \"\"\"\n    Registers database settings for a specific storage mode.\n\n    Args:\n        mode (int): The database mode identifier.\n        settings (Type[DatabaseSettings]): The settings class.\n\n    Returns:\n        bool: True if the database settings were successfully registered, False otherwise.\n\n    Raises:\n        ValueError: If an error occurs while registering the database settings.\n    \"\"\"\n\n    is_registered = False\n    if StorageModeOptions(mode) not in StorageModeOptions:\n        raise ValueError(\n            f'Unsupported Database Settings: {mode}. Available options: {storage_options}'\n        )\n\n    try:\n        cls.settings_mapping[StorageModeOptions(mode)] = settings\n        is_registered = True\n    except Exception as e:\n        raise ValueError(f'Error while registering database settings: {e}')\n\n    return is_registered\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-models/","title":"Database Models","text":"<p>This document provides details about the database orm models using SQLAlchemy. Below is the auto-generated documentation for the <code>PricingResearchModel</code> class.</p> <p>PricingResearchModel </p> <p>               Bases: <code>Base</code></p> <p>Represents a record of pricing research conducted for a product.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The primary key and auto-incremented identifier for each record.</p> <code>marketplace</code> <code>str</code> <p>The name of the marketplace where the product is listed.</p> <code>sku</code> <code>str</code> <p>The stock keeping unit of the product.</p> <code>marketplace_id</code> <code>str</code> <p>The unique identifier of the product within the marketplace.</p> <code>description</code> <code>str</code> <p>A description of the product.</p> <code>brand</code> <code>str</code> <p>The brand of the product.</p> <code>category</code> <code>str</code> <p>The category of the product within the marketplace.</p> <code>url</code> <code>str</code> <p>The URL of the product on the marketplace website.</p> <code>strategy</code> <code>str</code> <p>The strategy used for gathering pricing data.</p> <code>sellers</code> <code>JSON</code> <p>A JSON object containing information about the sellers offering the product.</p> <code>conducted_at</code> <code>datetime</code> <p>The timestamp when the research was conducted.</p> Table name <p>pricing_research</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/models.py</code> <pre><code>class PricingResearchModel(Base):\n    \"\"\"\n    Represents a record of pricing research conducted for a product.\n\n    Attributes:\n        id (int): The primary key and auto-incremented identifier for each record.\n        marketplace (str): The name of the marketplace where the product is listed.\n        sku (str): The stock keeping unit of the product.\n        marketplace_id (str): The unique identifier of the product within the marketplace.\n        description (str): A description of the product.\n        brand (str): The brand of the product.\n        category (str): The category of the product within the marketplace.\n        url (str): The URL of the product on the marketplace website.\n        strategy (str): The strategy used for gathering pricing data.\n        sellers (JSON): A JSON object containing information about the sellers offering the product.\n        conducted_at (datetime): The timestamp when the research was conducted.\n\n    Table name:\n        pricing_research\n    \"\"\"\n\n    __tablename__ = 'pricing_research'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n\n    marketplace = Column(String(255), nullable=True)\n    sku = Column(String(255), index=True, nullable=True)\n    marketplace_id = Column(String(255), nullable=True)\n    description = Column(String(1024), nullable=True)\n    brand = Column(String(255), nullable=True)\n    category = Column(String(255), nullable=True)\n    url = Column(String(512), nullable=True)\n    strategy = Column(String(255), nullable=True)\n    sellers = Column(JSON)\n\n    conducted_at = Column(\n        TIMESTAMP(timezone=True), default=lambda: datetime.now(tz=timezone.utc)\n    )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Provides a simple representation of a pricing research record, which can be useful for debugging.\n\n        Returns:\n            str: A string representation of the PricingResearchModel instance.\n        \"\"\"\n\n        return f\"&lt;PricingResearchModel(id={self.id}, url='{self.url}', strategy='{self.strategy}')&gt;\"\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-models/#kami_pricing_analytics.data_storage.modes.database.relational.PricingResearchModel.__repr__","title":"<code>__repr__()</code>","text":"<p>Provides a simple representation of a pricing research record, which can be useful for debugging.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PricingResearchModel instance.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/models.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Provides a simple representation of a pricing research record, which can be useful for debugging.\n\n    Returns:\n        str: A string representation of the PricingResearchModel instance.\n    \"\"\"\n\n    return f\"&lt;PricingResearchModel(id={self.id}, url='{self.url}', strategy='{self.strategy}')&gt;\"\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-settings/","title":"Database Settings","text":"<p>This document provides details about the database orm settings for successfull connection. Below is the auto-generated documentation for the <code>DatabaseSettings</code> class.</p> <p>DatabaseSettings </p> <p>               Bases: <code>BaseSettings</code></p> <p>Configuration settings for the database.</p> <p>Attributes:</p> Name Type Description <code>db_name</code> <code>str</code> <p>The name of the database.</p> <code>db_user</code> <code>str</code> <p>The username to connect to the database.</p> <code>db_password</code> <code>SecretStr</code> <p>The password to connect to the database.</p> <code>db_host</code> <code>str</code> <p>The host of the database, defaulting to 'localhost'.</p> <code>db_port</code> <code>int</code> <p>The port of the database.</p> <code>db_driver</code> <code>str</code> <p>The driver to connect to the database.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/settings.py</code> <pre><code>class DatabaseSettings(BaseSettings):\n    \"\"\"\n    Configuration settings for the database.\n\n    Attributes:\n        db_name (str): The name of the database.\n        db_user (str): The username to connect to the database.\n        db_password (SecretStr): The password to connect to the database.\n        db_host (str): The host of the database, defaulting to 'localhost'.\n        db_port (int): The port of the database.\n        db_driver (str): The driver to connect to the database.\n    \"\"\"\n\n    db_name: str\n    db_user: str\n    db_password: SecretStr\n    db_host: str = Field(default='localhost')\n    db_port: int\n    db_driver: str\n\n    model_config = ConfigDict(\n        title='Database Settings',\n        str_strip_whitespace=True,\n        env_file='.env',\n        env_file_encoding='utf-8',\n    )\n\n    @property\n    def db_url(self) -&gt; str:\n        \"\"\"\n        Constructs the database URL based on the database settings.\n\n        Returns:\n            str: The database URL.\n        \"\"\"\n        return f'{self.db_driver}://{self.db_user}:{self.db_password.get_secret_value()}@{self.db_host}:{self.db_port}/{self.db_name}'\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-settings/#kami_pricing_analytics.data_storage.modes.database.relational.DatabaseSettings.db_url","title":"<code>db_url: str</code>  <code>property</code>","text":"<p>Constructs the database URL based on the database settings.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The database URL.</p>"},{"location":"data_storage/modes/database/relational/db-storage/","title":"Database Storage","text":"<p>This document provides details about the database orm settings for successfull connection. Below is the auto-generated documentation for the <code>DatabaseStorage</code> class.</p> <p>DatabaseStorage </p> <p>               Bases: <code>BaseStorage</code></p> <p>Database storage class that provides methods to interact with the database.</p> <p>Attributes:</p> Name Type Description <code>_engine</code> <code>AsyncEngine</code> <p>The engine to connect to the database.</p> <code>_SessionLocal</code> <code>SessionLocal</code> <p>The session local class to create a session.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/storage.py</code> <pre><code>class DatabaseStorage(BaseStorage):\n    \"\"\"\n    Database storage class that provides methods to interact with the database.\n\n    Attributes:\n        _engine (AsyncEngine): The engine to connect to the database.\n        _SessionLocal (SessionLocal): The session local class to create a session.\n    \"\"\"\n\n    def __init__(self, settings: DatabaseSettings):\n        super().__init__(**settings.model_dump(exclude={'driver'}))\n\n        self._engine = create_async_engine(settings.db_url, echo=True)\n        self._SessionLocal = sessionmaker(\n            autocommit=False,\n            autoflush=False,\n            bind=self._engine,\n            class_=AsyncSession,\n        )\n\n    @asynccontextmanager\n    async def get_session(self) -&gt; AsyncGenerator[AsyncSession, None]:\n        \"\"\"\n        Provides a context manager that yields an async database session.\n\n        Yields:\n            AsyncSession: The async database session.\n\n        Example:\n            async with self.get_session() as session:\n                # Do something with the session.\n        \"\"\"\n        async with self._SessionLocal() as session:\n            yield session\n\n    async def save(\n        self,\n        data: Dict[str, Any],\n        model: Type[DeclarativeMeta] = PricingResearchModel,\n    ) -&gt; Any:\n        \"\"\"\n        Saves the PricingResearchModel instance to the database.\n\n        Args:\n            data (Dict[str, Any]): The data to save.\n            model (Type[DeclarativeMeta], optional): The model to save. Defaults to PricingResearchModel.\n\n        Returns:\n            Any: The saved instance.\n\n        Raises:\n            DatabaseStorageException: If an error occurs while saving the instance.\n        \"\"\"\n        try:\n            async with self.get_session() as session:\n                instance = model(**data)\n                session.add(instance)\n                await session.commit()\n        except Exception as e:\n            raise DatabaseStorageException(f'Error while saving instance: {e}')\n\n    async def retrieve(\n        self,\n        model: Type[DeclarativeMeta] = PricingResearchModel,\n        criteria: Dict[str, Any] = {},\n    ) -&gt; List[Any]:\n        \"\"\"\n        Retrieves the PricingResearchModel instances from the database.\n\n        Args:\n            model (Type[DeclarativeMeta], optional): The model to retrieve. Defaults to PricingResearchModel.\n            criteria (Dict[str, Any], optional): The criteria to filter the instances. Defaults to {}.\n\n        Returns:\n            List[Any]: The retrieved instances.\n\n        Raises:\n            DatabaseStorageException: If an error occurs while retrieving the instances.\n        \"\"\"\n        results = []\n        try:\n            async with self.get_session() as session:\n                query = (\n                    select(model)\n                    .filter_by(**criteria)\n                    .order_by(desc(model.conducted_at))\n                )\n                results = await session.execute(query)\n                results = results.scalars().all()\n        except Exception as e:\n            raise DatabaseStorageException(\n                f'Error while retrieving instances: {e}'\n            )\n\n        return results\n\n    async def update(\n        self,\n        criteria: Dict[str, Any],\n        data: Dict[str, Any],\n        model: Type[DeclarativeMeta] = PricingResearchModel,\n    ) -&gt; Any:\n        \"\"\"\n        Updates the PricingResearchModel instances in the database.\n\n        Args:\n            criteria (Dict[str, Any]): The criteria to filter the instances.\n            data (Dict[str, Any]): The data to update.\n            model (Type[DeclarativeMeta], optional): The model to update. Defaults to PricingResearchModel.\n\n        Returns:\n            Any: The updated instance.\n\n        Raises:\n            DatabaseStorageException: If an error occurs while updating the instance.\n        \"\"\"\n\n        instance = None\n        try:\n            async with self.get_session() as session:\n                stmt = (\n                    update(model)\n                    .filter_by(**criteria)\n                    .values(**data)\n                    .execution_options(synchronize_session='fetch')\n                )\n                instance = await session.execute(stmt)\n                instance = instance.scalars().first()\n                await session.commit()\n        except Exception as e:\n            raise DatabaseStorageException(\n                f'Error while updating instance: {e}'\n            )\n\n        return instance\n\n    async def delete(\n        self,\n        criteria: Dict[str, Any],\n        model: Type[DeclarativeMeta] = PricingResearchModel,\n    ) -&gt; Any:\n        \"\"\"\n        Deletes the PricingResearchModel instances from the database.\n\n        Args:\n            criteria (Dict[str, Any]): The criteria to filter the instances.\n            model (Type[DeclarativeMeta], optional): The model to delete. Defaults to PricingResearchModel.\n\n        Returns:\n            Any: The deleted instance.\n\n        Raises:\n            DatabaseStorageException: If an error occurs while deleting the instances.\n        \"\"\"\n        instance = None\n        try:\n            async with self.get_session() as session:\n                stmt = (\n                    delete(model)\n                    .filter_by(**criteria)\n                    .execution_options(synchronize_session='fetch')\n                )\n                instance = await session.execute(stmt)\n                instance = instance.scalars().first()\n                await session.commit()\n        except Exception as e:\n            raise DatabaseStorageException(\n                f'Error while deleting instance: {e}'\n            )\n\n        return instance\n</code></pre> <p>DatabaseStorageException </p> <p>               Bases: <code>Exception</code></p> <p>Custom exception class for database storage exceptions.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/storage.py</code> <pre><code>class DatabaseStorageException(Exception):\n    \"\"\"\n    Custom exception class for database storage exceptions.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-storage/#kami_pricing_analytics.data_storage.modes.database.relational.DatabaseStorage.delete","title":"<code>delete(criteria, model=PricingResearchModel)</code>  <code>async</code>","text":"<p>Deletes the PricingResearchModel instances from the database.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <code>Dict[str, Any]</code> <p>The criteria to filter the instances.</p> required <code>model</code> <code>Type[DeclarativeMeta]</code> <p>The model to delete. Defaults to PricingResearchModel.</p> <code>PricingResearchModel</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The deleted instance.</p> <p>Raises:</p> Type Description <code>DatabaseStorageException</code> <p>If an error occurs while deleting the instances.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/storage.py</code> <pre><code>async def delete(\n    self,\n    criteria: Dict[str, Any],\n    model: Type[DeclarativeMeta] = PricingResearchModel,\n) -&gt; Any:\n    \"\"\"\n    Deletes the PricingResearchModel instances from the database.\n\n    Args:\n        criteria (Dict[str, Any]): The criteria to filter the instances.\n        model (Type[DeclarativeMeta], optional): The model to delete. Defaults to PricingResearchModel.\n\n    Returns:\n        Any: The deleted instance.\n\n    Raises:\n        DatabaseStorageException: If an error occurs while deleting the instances.\n    \"\"\"\n    instance = None\n    try:\n        async with self.get_session() as session:\n            stmt = (\n                delete(model)\n                .filter_by(**criteria)\n                .execution_options(synchronize_session='fetch')\n            )\n            instance = await session.execute(stmt)\n            instance = instance.scalars().first()\n            await session.commit()\n    except Exception as e:\n        raise DatabaseStorageException(\n            f'Error while deleting instance: {e}'\n        )\n\n    return instance\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-storage/#kami_pricing_analytics.data_storage.modes.database.relational.DatabaseStorage.get_session","title":"<code>get_session()</code>  <code>async</code>","text":"<p>Provides a context manager that yields an async database session.</p> <p>Yields:</p> Name Type Description <code>AsyncSession</code> <code>AsyncGenerator[AsyncSession, None]</code> <p>The async database session.</p> Example <p>async with self.get_session() as session:     # Do something with the session.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/storage.py</code> <pre><code>@asynccontextmanager\nasync def get_session(self) -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"\n    Provides a context manager that yields an async database session.\n\n    Yields:\n        AsyncSession: The async database session.\n\n    Example:\n        async with self.get_session() as session:\n            # Do something with the session.\n    \"\"\"\n    async with self._SessionLocal() as session:\n        yield session\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-storage/#kami_pricing_analytics.data_storage.modes.database.relational.DatabaseStorage.retrieve","title":"<code>retrieve(model=PricingResearchModel, criteria={})</code>  <code>async</code>","text":"<p>Retrieves the PricingResearchModel instances from the database.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[DeclarativeMeta]</code> <p>The model to retrieve. Defaults to PricingResearchModel.</p> <code>PricingResearchModel</code> <code>criteria</code> <code>Dict[str, Any]</code> <p>The criteria to filter the instances. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]: The retrieved instances.</p> <p>Raises:</p> Type Description <code>DatabaseStorageException</code> <p>If an error occurs while retrieving the instances.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/storage.py</code> <pre><code>async def retrieve(\n    self,\n    model: Type[DeclarativeMeta] = PricingResearchModel,\n    criteria: Dict[str, Any] = {},\n) -&gt; List[Any]:\n    \"\"\"\n    Retrieves the PricingResearchModel instances from the database.\n\n    Args:\n        model (Type[DeclarativeMeta], optional): The model to retrieve. Defaults to PricingResearchModel.\n        criteria (Dict[str, Any], optional): The criteria to filter the instances. Defaults to {}.\n\n    Returns:\n        List[Any]: The retrieved instances.\n\n    Raises:\n        DatabaseStorageException: If an error occurs while retrieving the instances.\n    \"\"\"\n    results = []\n    try:\n        async with self.get_session() as session:\n            query = (\n                select(model)\n                .filter_by(**criteria)\n                .order_by(desc(model.conducted_at))\n            )\n            results = await session.execute(query)\n            results = results.scalars().all()\n    except Exception as e:\n        raise DatabaseStorageException(\n            f'Error while retrieving instances: {e}'\n        )\n\n    return results\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-storage/#kami_pricing_analytics.data_storage.modes.database.relational.DatabaseStorage.save","title":"<code>save(data, model=PricingResearchModel)</code>  <code>async</code>","text":"<p>Saves the PricingResearchModel instance to the database.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data to save.</p> required <code>model</code> <code>Type[DeclarativeMeta]</code> <p>The model to save. Defaults to PricingResearchModel.</p> <code>PricingResearchModel</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The saved instance.</p> <p>Raises:</p> Type Description <code>DatabaseStorageException</code> <p>If an error occurs while saving the instance.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/storage.py</code> <pre><code>async def save(\n    self,\n    data: Dict[str, Any],\n    model: Type[DeclarativeMeta] = PricingResearchModel,\n) -&gt; Any:\n    \"\"\"\n    Saves the PricingResearchModel instance to the database.\n\n    Args:\n        data (Dict[str, Any]): The data to save.\n        model (Type[DeclarativeMeta], optional): The model to save. Defaults to PricingResearchModel.\n\n    Returns:\n        Any: The saved instance.\n\n    Raises:\n        DatabaseStorageException: If an error occurs while saving the instance.\n    \"\"\"\n    try:\n        async with self.get_session() as session:\n            instance = model(**data)\n            session.add(instance)\n            await session.commit()\n    except Exception as e:\n        raise DatabaseStorageException(f'Error while saving instance: {e}')\n</code></pre>"},{"location":"data_storage/modes/database/relational/db-storage/#kami_pricing_analytics.data_storage.modes.database.relational.DatabaseStorage.update","title":"<code>update(criteria, data, model=PricingResearchModel)</code>  <code>async</code>","text":"<p>Updates the PricingResearchModel instances in the database.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <code>Dict[str, Any]</code> <p>The criteria to filter the instances.</p> required <code>data</code> <code>Dict[str, Any]</code> <p>The data to update.</p> required <code>model</code> <code>Type[DeclarativeMeta]</code> <p>The model to update. Defaults to PricingResearchModel.</p> <code>PricingResearchModel</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The updated instance.</p> <p>Raises:</p> Type Description <code>DatabaseStorageException</code> <p>If an error occurs while updating the instance.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/storage.py</code> <pre><code>async def update(\n    self,\n    criteria: Dict[str, Any],\n    data: Dict[str, Any],\n    model: Type[DeclarativeMeta] = PricingResearchModel,\n) -&gt; Any:\n    \"\"\"\n    Updates the PricingResearchModel instances in the database.\n\n    Args:\n        criteria (Dict[str, Any]): The criteria to filter the instances.\n        data (Dict[str, Any]): The data to update.\n        model (Type[DeclarativeMeta], optional): The model to update. Defaults to PricingResearchModel.\n\n    Returns:\n        Any: The updated instance.\n\n    Raises:\n        DatabaseStorageException: If an error occurs while updating the instance.\n    \"\"\"\n\n    instance = None\n    try:\n        async with self.get_session() as session:\n            stmt = (\n                update(model)\n                .filter_by(**criteria)\n                .values(**data)\n                .execution_options(synchronize_session='fetch')\n            )\n            instance = await session.execute(stmt)\n            instance = instance.scalars().first()\n            await session.commit()\n    except Exception as e:\n        raise DatabaseStorageException(\n            f'Error while updating instance: {e}'\n        )\n\n    return instance\n</code></pre>"},{"location":"data_storage/modes/database/relational/mssql/","title":"Microsoft SQL Server","text":"<p>This document provides details about the database orm connection with Microsoft SQL Server Below is the auto-generated documentation for the <code>SQLServerSettings</code> and <code>SQLServerStorage</code> classes.</p> <p>SQLServerStorage </p> <p>               Bases: <code>DatabaseStorage</code></p> <p>Storage class for Microsoft SQL Server using the specified settings.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/mssql.py</code> <pre><code>class SQLServerStorage(DatabaseStorage):\n    \"\"\"Storage class for Microsoft SQL Server using the specified settings.\"\"\"\n\n    def __init__(self, settings: SQLServerSettings):\n        super().__init__(settings)\n</code></pre> <p>SQLServerSettings </p> <p>               Bases: <code>DatabaseSettings</code></p> <p>Configuration settings specific to Microsoft SQL Server.</p> <p>Attributes:</p> Name Type Description <code>db_driver</code> <code>str</code> <p>Database driver, defaulting to 'mssql+aiomssql'.</p> <code>db_port</code> <code>int</code> <p>Database port, default is 1433.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/mssql.py</code> <pre><code>class SQLServerSettings(DatabaseSettings):\n    \"\"\"\n    Configuration settings specific to Microsoft SQL Server.\n\n    Attributes:\n        db_driver (str): Database driver, defaulting to 'mssql+aiomssql'.\n        db_port (int): Database port, default is 1433.\n    \"\"\"\n\n    db_driver: str = 'mssql+aiomssql'\n    db_port: int = Field(default=1433)\n\n    @property\n    def db_url(self) -&gt; str:\n        \"\"\"Constructs the database URL based on the SQL Server settings.\"\"\"\n        return f'{self.db_driver}://{self.db_user}:{self.db_password}@{self.db_host}:{self.db_port}/{self.db_name}'\n</code></pre>"},{"location":"data_storage/modes/database/relational/mssql/#kami_pricing_analytics.data_storage.modes.database.relational.SQLServerSettings.db_url","title":"<code>db_url: str</code>  <code>property</code>","text":"<p>Constructs the database URL based on the SQL Server settings.</p>"},{"location":"data_storage/modes/database/relational/mysql/","title":"MySQL","text":"<p>This document provides details about the database orm connection with MySQL Below is the auto-generated documentation for the <code>MySQLSettings</code> and <code>MySQLStorage</code> classes.</p> <p>MySQLStorage </p> <p>               Bases: <code>DatabaseStorage</code></p> <p>Storage class for MySQL database using the specified settings.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/mysql.py</code> <pre><code>class MySQLStorage(DatabaseStorage):\n    \"\"\"Storage class for MySQL database using the specified settings.\"\"\"\n\n    def __init__(self, settings: MySQLSettings):\n        super().__init__(settings)\n</code></pre> <p>MySQLSettings </p> <p>               Bases: <code>DatabaseSettings</code></p> <p>Configuration settings specific to MySQL database.</p> <p>Attributes:</p> Name Type Description <code>db_driver</code> <code>str</code> <p>Database driver, defaulting to 'mysql+aiomysql'.</p> <code>db_port</code> <code>int</code> <p>Database port, default is 3306.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/mysql.py</code> <pre><code>class MySQLSettings(DatabaseSettings):\n    \"\"\"\n    Configuration settings specific to MySQL database.\n\n    Attributes:\n        db_driver (str): Database driver, defaulting to 'mysql+aiomysql'.\n        db_port (int): Database port, default is 3306.\n    \"\"\"\n\n    db_driver: str = 'mysql+aiomysql'\n    db_port: int = Field(default=3306)\n\n    @property\n    def db_url(self) -&gt; str:\n        \"\"\"Constructs the database URL based on the MySQL settings.\"\"\"\n        return f'{self.db_driver}://{self.db_user}:{self.db_password.get_secret_value()}@{self.db_host}:{self.db_port}/{self.db_name}'\n</code></pre>"},{"location":"data_storage/modes/database/relational/mysql/#kami_pricing_analytics.data_storage.modes.database.relational.MySQLSettings.db_url","title":"<code>db_url: str</code>  <code>property</code>","text":"<p>Constructs the database URL based on the MySQL settings.</p>"},{"location":"data_storage/modes/database/relational/plsql/","title":"Oracle PL/SQL","text":"<p>This document provides details about the database orm connection with Oracle PL/SQL Below is the auto-generated documentation for the <code>PLSQLSettings</code> and <code>PLSQLStorage</code> classes.</p> <p>PLSQLStorage </p> <p>               Bases: <code>DatabaseStorage</code></p> <p>Storage class for Oracle PL/SQL database using the specified settings.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/plsql.py</code> <pre><code>class PLSQLStorage(DatabaseStorage):\n    \"\"\"Storage class for Oracle PL/SQL database using the specified settings.\"\"\"\n\n    def __init__(self, settings: PLSQLSettings):\n        super().__init__(settings)\n</code></pre> <p>PLSQLSettings </p> <p>               Bases: <code>DatabaseSettings</code></p> <p>Configuration settings specific to Oracle PL/SQL database.</p> <p>Attributes:</p> Name Type Description <code>db_driver</code> <code>str</code> <p>Database driver, defaulting to 'oracle+cx_oracle'.</p> <code>db_port</code> <code>int</code> <p>Database port, default is 1521.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/plsql.py</code> <pre><code>class PLSQLSettings(DatabaseSettings):\n    \"\"\"\n    Configuration settings specific to Oracle PL/SQL database.\n\n    Attributes:\n        db_driver (str): Database driver, defaulting to 'oracle+cx_oracle'.\n        db_port (int): Database port, default is 1521.\n    \"\"\"\n\n    db_driver: str = 'oracle+cx_oracle'\n    db_port: int = Field(default=1521)\n\n    @property\n    def db_url(self):\n        return f'{self.db_driver}://{self.db_user}:{self.db_password}@{self.db_host}:{self.db_port}/{self.db_name}'\n</code></pre>"},{"location":"data_storage/modes/database/relational/postgresql/","title":"PostgreSQL","text":"<p>This document provides details about the database orm connection with PostgreSQL Below is the auto-generated documentation for the <code>PostgreSQLSettings</code> and <code>PostgreSQLStorage</code> classes.</p> <p>PostgreSQLStorage </p> <p>               Bases: <code>DatabaseStorage</code></p> <p>Storage class for PostgreSQL database using the specified settings.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/postgresql.py</code> <pre><code>class PostgreSQLStorage(DatabaseStorage):\n    \"\"\"Storage class for PostgreSQL database using the specified settings.\"\"\"\n\n    def __init__(self, settings: PostgreSQLSettings):\n        super().__init__(settings)\n</code></pre> <p>PostgreSQLSettings </p> <p>               Bases: <code>DatabaseSettings</code></p> <p>Configuration settings specific to PostgreSQL database.</p> <p>Attributes:</p> Name Type Description <code>db_driver</code> <code>str</code> <p>Database driver, defaulting to 'postgresql+asyncpg'.</p> <code>db_port</code> <code>int</code> <p>Database port, default is 5432.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/postgresql.py</code> <pre><code>class PostgreSQLSettings(DatabaseSettings):\n    \"\"\"\n    Configuration settings specific to PostgreSQL database.\n\n    Attributes:\n        db_driver (str): Database driver, defaulting to 'postgresql+asyncpg'.\n        db_port (int): Database port, default is 5432.\n    \"\"\"\n\n    db_driver: str = 'postgresql+asyncpg'\n    db_port: int = Field(5432)\n\n    @property\n    def db_url(self) -&gt; str:\n        \"\"\"Constructs the database URL based on the PostgreSQL settings.\"\"\"\n        return f'{self.db_driver}://{self.db_user}:{self.db_password.get_secret_value()}@{self.db_host}:{self.db_port}/{self.db_name}'\n</code></pre>"},{"location":"data_storage/modes/database/relational/postgresql/#kami_pricing_analytics.data_storage.modes.database.relational.PostgreSQLSettings.db_url","title":"<code>db_url: str</code>  <code>property</code>","text":"<p>Constructs the database URL based on the PostgreSQL settings.</p>"},{"location":"data_storage/modes/database/relational/sqlite/","title":"SQLite","text":"<p>This document provides details about the database orm connection with SQLite Below is the auto-generated documentation for the <code>SQLiteSettings</code> and <code>SQLiteStorage</code> classes.</p> <p>SQLiteStorage </p> <p>               Bases: <code>DatabaseStorage</code></p> <p>Storage class for SQLite database using the specified settings.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/sqlite.py</code> <pre><code>class SQLiteStorage(DatabaseStorage):\n    \"\"\"Storage class for SQLite database using the specified settings.\"\"\"\n\n    def __init__(self, settings: SQLiteSettings):\n        super().__init__(settings=settings)\n</code></pre> <p>SQLiteSettings </p> <p>               Bases: <code>DatabaseSettings</code></p> <p>Configuration settings specific to SQLite database.</p> <p>Attributes:</p> Name Type Description <code>db_driver</code> <code>str</code> <p>Database driver, defaulting to 'sqlite+aiosqlite'.</p> <code>db_port</code> <code>int</code> <p>Database port, not applicable for SQLite hence set to 0.</p> Source code in <code>kami_pricing_analytics/data_storage/modes/database/relational/sqlite.py</code> <pre><code>class SQLiteSettings(DatabaseSettings):\n    \"\"\"\n    Configuration settings specific to SQLite database.\n\n    Attributes:\n        db_driver (str): Database driver, defaulting to 'sqlite+aiosqlite'.\n        db_port (int): Database port, not applicable for SQLite hence set to 0.\n    \"\"\"\n\n    db_driver: str = 'sqlite+aiosqlite'\n    db_port: int = Field(default=0)\n\n    @property\n    def db_url(self) -&gt; str:\n        \"\"\"Constructs the database URL based on the SQLite settings.\"\"\"\n        db_url = (\n            self.db_name\n            if self.db_name == ':memory:'\n            else f'{self.db_name}.db'\n        )\n        return f'{self.db_driver}:///{db_url}'\n</code></pre>"},{"location":"data_storage/modes/database/relational/sqlite/#kami_pricing_analytics.data_storage.modes.database.relational.SQLiteSettings.db_url","title":"<code>db_url: str</code>  <code>property</code>","text":"<p>Constructs the database URL based on the SQLite settings.</p>"},{"location":"interface/api/pricing-research-request/","title":"Pricing Research Request","text":"<p>This document provides details about Pricing Research Request functionality. Below is the auto-generated documentation for the <code>PricingResearchRequest</code> class.</p> <p>               Bases: <code>BaseModel</code></p> <p>Handles the construction and submission of pricing research requests.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>Optional[str]</code> <p>The URL of the product.</p> <code>marketplace</code> <code>Optional[str]</code> <p>The marketplace name.</p> <code>marketplace_id</code> <code>Optional[str]</code> <p>The product ID within the marketplace.</p> <code>collector_option</code> <code>int</code> <p>The scraping strategy to be used.</p> <code>store_result</code> <code>bool</code> <p>Flag indicating whether to store the research results.</p> <code>service</code> <code>PricingService</code> <p>An instance of PricingService to execute the research.</p> Source code in <code>kami_pricing_analytics/interface/api/pricing_research_request.py</code> <pre><code>class PricingResearchRequest(BaseModel):\n    \"\"\"\n    Handles the construction and submission of pricing research requests.\n\n    Attributes:\n        url (Optional[str]): The URL of the product.\n        marketplace (Optional[str]): The marketplace name.\n        marketplace_id (Optional[str]): The product ID within the marketplace.\n        collector_option (int): The scraping strategy to be used.\n        store_result (bool): Flag indicating whether to store the research results.\n        service (PricingService): An instance of PricingService to execute the research.\n    \"\"\"\n\n    url: Optional[str] = Field(default=None)\n    marketplace: Optional[str] = Field(default=None)\n    marketplace_id: Optional[str] = Field(default=None)\n    collector_option: int = Field(default=CollectorOptions.WEB_SCRAPING.value)\n    store_result: bool = Field(default=False)\n    service: PricingService = Field(default=None)\n\n    def validate_strategy_option(self) -&gt; 'PricingResearchRequest':\n        \"\"\"\n        Validates the strategy option to ensure it is recognized.\n\n        Raises:\n            ValueError: If the strategy option is invalid.\n\n        Returns:\n            PricingResearchRequest: The instance of this request with a validated strategy.\n        \"\"\"\n        if self.collector_option not in CollectorOptions._value2member_map_:\n            raise PricingResearchRequestException(\n                f'Invalid strategy option {self.collector_option}. Available options are: {list(CollectorOptions)}'\n            )\n        return self\n\n    def validate_research(self) -&gt; 'PricingResearchRequest':\n        \"\"\"\n        Validates the necessary parameters for conducting research.\n\n        Raises:\n            ValueError: If neither URL nor marketplace and marketplace_id are provided.\n\n        Returns:\n            PricingResearchRequest: The instance of this request with validated research parameters.\n        \"\"\"\n        if self.url:\n            return self\n\n        if not self.marketplace or not self.marketplace_id:\n            raise PricingResearchRequestException(\n                'Either Product URL or marketplace and marketplace_id is required to conduct research.'\n            )\n\n        return self\n\n    @model_validator(mode='after')\n    def validate_input(self) -&gt; 'PricingResearchRequest':\n        \"\"\"\n        Performs input validation by checking strategy options and research parameters.\n\n        Returns:\n            PricingResearchRequest: The validated request instance.\n        \"\"\"\n        try:\n            self.validate_strategy_option()\n            self.validate_research()\n        except ValueError as e:\n            raise PricingResearchRequestException(\n                f'Value Error while validating input: {e}'\n            )\n        except Exception as e:\n            raise PricingResearchRequestException(\n                f'Unexpected error while validating input: {e}'\n            )\n        return self\n\n    @model_validator(mode='after')\n    def get_service_instance(self) -&gt; 'PricingResearchRequest':\n        \"\"\"\n        Initializes the PricingService based on the request's parameters.\n\n        Returns:\n            PricingResearchRequest: The request instance with an initialized service.\n        \"\"\"\n        try:\n            research = PricingResearch(\n                url=self.url,\n                marketplace=self.marketplace,\n                marketplace_id=self.marketplace_id,\n            )\n            self.service = PricingService(\n                collector_option=self.collector_option,\n                research=research,\n                store_result=self.store_result,\n                storage_mode=storage_mode,\n            )\n        except ValueError as e:\n            raise PricingResearchRequestException(\n                f'Value Error while getting service instance: {e}'\n            )\n        except Exception as e:\n            raise PricingResearchRequestException(\n                f'Unexpected error while getting service instance: {e}'\n            )\n        return self\n\n    async def post(self) -&gt; List[Dict]:\n        \"\"\"\n        Submits the pricing research request and optionally stores the results.\n\n        Returns:\n            List[Dict]: A list of seller data from the conducted research.\n\n        Raises:\n            PricingResearchRequestError: If an error occurs during processing.\n        \"\"\"\n\n        response = []\n        try:\n            self.validate_input()\n            self.service.set_strategy()\n            await self.service.conduct_research()\n\n            if self.store_result:\n                self.service.set_storage()\n                asyncio.create_task(self.service.store_research())\n\n            response = self.service.research.sellers\n        except ValueError as e:\n            raise ValueError(f'Value Error while processing research: {e}')\n        except Exception as e:\n            raise ValueError(\n                f'Unexpected error while processing research: {e}'\n            )\n\n        return response\n\n    async def get(self) -&gt; List[Dict]:\n        \"\"\"\n        Retrieves pricing research data or triggers a new research if necessary.\n\n        Returns:\n            List[Dict]: A list of seller data from the retrieved or newly conducted research.\n\n        Raises:\n            PricingResearchRequestError: If an error occurs during retrieval or processing.\n        \"\"\"\n\n        response = []\n\n        try:\n            await self.service.retrieve_research()\n\n            if (\n                not self.service.research.sellers\n                or self.service.research.expired\n            ):\n                self.store_result = True\n                await self.post()\n\n            reponse = self.service.research.sellers\n        except ValueError as e:\n            raise PricingResearchRequestException(\n                f'Value Error while getting research: {e}'\n            )\n        except Exception as e:\n            raise PricingResearchRequestException(\n                f'Unexpected error while getting research: {e}'\n            )\n\n        return response\n</code></pre>"},{"location":"interface/api/pricing-research-request/#kami_pricing_analytics.interface.api.PricingResearchRequest.get","title":"<code>get()</code>  <code>async</code>","text":"<p>Retrieves pricing research data or triggers a new research if necessary.</p> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of seller data from the retrieved or newly conducted research.</p> <p>Raises:</p> Type Description <code>PricingResearchRequestError</code> <p>If an error occurs during retrieval or processing.</p> Source code in <code>kami_pricing_analytics/interface/api/pricing_research_request.py</code> <pre><code>async def get(self) -&gt; List[Dict]:\n    \"\"\"\n    Retrieves pricing research data or triggers a new research if necessary.\n\n    Returns:\n        List[Dict]: A list of seller data from the retrieved or newly conducted research.\n\n    Raises:\n        PricingResearchRequestError: If an error occurs during retrieval or processing.\n    \"\"\"\n\n    response = []\n\n    try:\n        await self.service.retrieve_research()\n\n        if (\n            not self.service.research.sellers\n            or self.service.research.expired\n        ):\n            self.store_result = True\n            await self.post()\n\n        reponse = self.service.research.sellers\n    except ValueError as e:\n        raise PricingResearchRequestException(\n            f'Value Error while getting research: {e}'\n        )\n    except Exception as e:\n        raise PricingResearchRequestException(\n            f'Unexpected error while getting research: {e}'\n        )\n\n    return response\n</code></pre>"},{"location":"interface/api/pricing-research-request/#kami_pricing_analytics.interface.api.PricingResearchRequest.get_service_instance","title":"<code>get_service_instance()</code>","text":"<p>Initializes the PricingService based on the request's parameters.</p> <p>Returns:</p> Name Type Description <code>PricingResearchRequest</code> <code>PricingResearchRequest</code> <p>The request instance with an initialized service.</p> Source code in <code>kami_pricing_analytics/interface/api/pricing_research_request.py</code> <pre><code>@model_validator(mode='after')\ndef get_service_instance(self) -&gt; 'PricingResearchRequest':\n    \"\"\"\n    Initializes the PricingService based on the request's parameters.\n\n    Returns:\n        PricingResearchRequest: The request instance with an initialized service.\n    \"\"\"\n    try:\n        research = PricingResearch(\n            url=self.url,\n            marketplace=self.marketplace,\n            marketplace_id=self.marketplace_id,\n        )\n        self.service = PricingService(\n            collector_option=self.collector_option,\n            research=research,\n            store_result=self.store_result,\n            storage_mode=storage_mode,\n        )\n    except ValueError as e:\n        raise PricingResearchRequestException(\n            f'Value Error while getting service instance: {e}'\n        )\n    except Exception as e:\n        raise PricingResearchRequestException(\n            f'Unexpected error while getting service instance: {e}'\n        )\n    return self\n</code></pre>"},{"location":"interface/api/pricing-research-request/#kami_pricing_analytics.interface.api.PricingResearchRequest.post","title":"<code>post()</code>  <code>async</code>","text":"<p>Submits the pricing research request and optionally stores the results.</p> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of seller data from the conducted research.</p> <p>Raises:</p> Type Description <code>PricingResearchRequestError</code> <p>If an error occurs during processing.</p> Source code in <code>kami_pricing_analytics/interface/api/pricing_research_request.py</code> <pre><code>async def post(self) -&gt; List[Dict]:\n    \"\"\"\n    Submits the pricing research request and optionally stores the results.\n\n    Returns:\n        List[Dict]: A list of seller data from the conducted research.\n\n    Raises:\n        PricingResearchRequestError: If an error occurs during processing.\n    \"\"\"\n\n    response = []\n    try:\n        self.validate_input()\n        self.service.set_strategy()\n        await self.service.conduct_research()\n\n        if self.store_result:\n            self.service.set_storage()\n            asyncio.create_task(self.service.store_research())\n\n        response = self.service.research.sellers\n    except ValueError as e:\n        raise ValueError(f'Value Error while processing research: {e}')\n    except Exception as e:\n        raise ValueError(\n            f'Unexpected error while processing research: {e}'\n        )\n\n    return response\n</code></pre>"},{"location":"interface/api/pricing-research-request/#kami_pricing_analytics.interface.api.PricingResearchRequest.validate_input","title":"<code>validate_input()</code>","text":"<p>Performs input validation by checking strategy options and research parameters.</p> <p>Returns:</p> Name Type Description <code>PricingResearchRequest</code> <code>PricingResearchRequest</code> <p>The validated request instance.</p> Source code in <code>kami_pricing_analytics/interface/api/pricing_research_request.py</code> <pre><code>@model_validator(mode='after')\ndef validate_input(self) -&gt; 'PricingResearchRequest':\n    \"\"\"\n    Performs input validation by checking strategy options and research parameters.\n\n    Returns:\n        PricingResearchRequest: The validated request instance.\n    \"\"\"\n    try:\n        self.validate_strategy_option()\n        self.validate_research()\n    except ValueError as e:\n        raise PricingResearchRequestException(\n            f'Value Error while validating input: {e}'\n        )\n    except Exception as e:\n        raise PricingResearchRequestException(\n            f'Unexpected error while validating input: {e}'\n        )\n    return self\n</code></pre>"},{"location":"interface/api/pricing-research-request/#kami_pricing_analytics.interface.api.PricingResearchRequest.validate_research","title":"<code>validate_research()</code>","text":"<p>Validates the necessary parameters for conducting research.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither URL nor marketplace and marketplace_id are provided.</p> <p>Returns:</p> Name Type Description <code>PricingResearchRequest</code> <code>PricingResearchRequest</code> <p>The instance of this request with validated research parameters.</p> Source code in <code>kami_pricing_analytics/interface/api/pricing_research_request.py</code> <pre><code>def validate_research(self) -&gt; 'PricingResearchRequest':\n    \"\"\"\n    Validates the necessary parameters for conducting research.\n\n    Raises:\n        ValueError: If neither URL nor marketplace and marketplace_id are provided.\n\n    Returns:\n        PricingResearchRequest: The instance of this request with validated research parameters.\n    \"\"\"\n    if self.url:\n        return self\n\n    if not self.marketplace or not self.marketplace_id:\n        raise PricingResearchRequestException(\n            'Either Product URL or marketplace and marketplace_id is required to conduct research.'\n        )\n\n    return self\n</code></pre>"},{"location":"interface/api/pricing-research-request/#kami_pricing_analytics.interface.api.PricingResearchRequest.validate_strategy_option","title":"<code>validate_strategy_option()</code>","text":"<p>Validates the strategy option to ensure it is recognized.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the strategy option is invalid.</p> <p>Returns:</p> Name Type Description <code>PricingResearchRequest</code> <code>PricingResearchRequest</code> <p>The instance of this request with a validated strategy.</p> Source code in <code>kami_pricing_analytics/interface/api/pricing_research_request.py</code> <pre><code>def validate_strategy_option(self) -&gt; 'PricingResearchRequest':\n    \"\"\"\n    Validates the strategy option to ensure it is recognized.\n\n    Raises:\n        ValueError: If the strategy option is invalid.\n\n    Returns:\n        PricingResearchRequest: The instance of this request with a validated strategy.\n    \"\"\"\n    if self.collector_option not in CollectorOptions._value2member_map_:\n        raise PricingResearchRequestException(\n            f'Invalid strategy option {self.collector_option}. Available options are: {list(CollectorOptions)}'\n        )\n    return self\n</code></pre>"},{"location":"interface/api/pricing-research-request/#pricing-research-request-exception","title":"Pricing Research Request Exception","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for PricingResearchRequest-realted errors.</p> Source code in <code>kami_pricing_analytics/interface/api/pricing_research_request.py</code> <pre><code>class PricingResearchRequestException(Exception):\n    \"\"\"\n    Custom exception for PricingResearchRequest-realted errors.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"interface/api/fastapi/app/","title":"FastAPI Implementation","text":"<p>This document provides details about FastAPI Implementation functionality. Below is the auto-generated documentation for the <code>PricingResearchPayload</code> class.</p> <p>               Bases: <code>BaseModel</code></p> <p>Data model for receiving pricing research requests.</p> Fields <p>url (Optional[str]): URL of the product on the marketplace. marketplace (Optional[str]): Name of the marketplace. marketplace_id (Optional[str]): ID of the product on the marketplace. collector_option (int): Strategy to be used to collect the data, defaulting to web scraping. store_result (bool): Whether to store the results in a database.</p> Source code in <code>kami_pricing_analytics/interface/api/fastapi/app.py</code> <pre><code>class PricingResearchPayload(BaseModel):\n    \"\"\"\n    Data model for receiving pricing research requests.\n\n    Fields:\n        url (Optional[str]): URL of the product on the marketplace.\n        marketplace (Optional[str]): Name of the marketplace.\n        marketplace_id (Optional[str]): ID of the product on the marketplace.\n        collector_option (int): Strategy to be used to collect the data, defaulting to web scraping.\n        store_result (bool): Whether to store the results in a database.\n    \"\"\"\n\n    url: Optional[str] = Field(default=None)\n    marketplace: Optional[str] = Field(default=None)\n    marketplace_id: Optional[str] = Field(default=None)\n    collector_option: int = Field(default=CollectorOptions.WEB_SCRAPING.value)\n    store_result: bool = Field(default=False)\n</code></pre>"},{"location":"schemas/pricing-research/","title":"Pricing Research","text":"<p>This document provides details about Pricing Research functionality. Below is the auto-generated documentation for the <code>PricingResearch</code> class.</p> <p>               Bases: <code>BaseModel</code></p> <p>Defines the schema for pricing research data, including validation and URL handling.</p> <p>Attributes:</p> Name Type Description <code>sku</code> <code>str</code> <p>Stock Keeping Unit identifier for the product.</p> <code>url</code> <code>Optional[HttpUrl]</code> <p>Product URL in the marketplace.</p> <code>marketplace</code> <code>Optional[str]</code> <p>Name of the marketplace.</p> <code>marketplace_id</code> <code>Optional[str]</code> <p>Unique identifier of the product in the marketplace.</p> <code>description</code> <code>str</code> <p>Description of the product.</p> <code>brand</code> <code>str</code> <p>Brand of the product.</p> <code>category</code> <code>str</code> <p>Product category.</p> <code>sellers</code> <code>List[Dict]</code> <p>List of sellers offering the product.</p> <code>conducted_at</code> <code>datetime</code> <p>Timestamp when the research was conducted.</p> Source code in <code>kami_pricing_analytics/schemas/pricing_research.py</code> <pre><code>class PricingResearch(BaseModel):\n    \"\"\"\n    Defines the schema for pricing research data, including validation and URL handling.\n\n    Attributes:\n        sku (str): Stock Keeping Unit identifier for the product.\n        url (Optional[HttpUrl]): Product URL in the marketplace.\n        marketplace (Optional[str]): Name of the marketplace.\n        marketplace_id (Optional[str]): Unique identifier of the product in the marketplace.\n        description (str): Description of the product.\n        brand (str): Brand of the product.\n        category (str): Product category.\n        sellers (List[Dict]): List of sellers offering the product.\n        conducted_at (datetime): Timestamp when the research was conducted.\n    \"\"\"\n\n    sku: str = Field(default=None)\n    url: Optional[HttpUrl] = Field(default=None)\n    marketplace: Optional[str] = Field(default=None)\n    marketplace_id: Optional[str] = Field(default=None)\n    description: str = Field(default=None)\n    brand: str = Field(default=None)\n    category: str = Field(default=None)\n    sellers: List[Dict] = Field(default=None)\n    conducted_at: datetime = Field(default=None)\n\n    model_config = ConfigDict(\n        title='Pricing Research',\n        from_attributes=True,\n        use_enum_values=True,\n        str_strip_whitespace=True,\n    )\n\n    @model_validator(mode='after')\n    def ensure_url_or_marketplace(self) -&gt; 'PricingResearch':\n        \"\"\"\n        Validates the presence of either a URL or marketplace and marketplace_id.\n\n        Returns:\n            PricingResearch: The instance of the PricingResearch model.\n\n        Raises:\n            PricingResearchException: If neither URL nor marketplace and marketplace_id are provided.\n        \"\"\"\n        if self.url:\n            return self\n\n        if not self.marketplace or not self.marketplace_id:\n            raise PricingResearchException(\n                'Either Product URL or marketplace and marketplace_id is required to conduct research.'\n            )\n\n        return self\n\n    @model_validator(mode='after')\n    def set_url(self) -&gt; 'PricingResearch':\n        \"\"\"\n        Sets the product URL based on the marketplace and marketplace_id if not provided.\n\n        Returns:\n            PricingResearch: The instance of the PricingResearch model.\n\n        Raises:\n            PricingResearchException: If unable to set the URL due to missing configuration.\n        \"\"\"\n        if not self.url and (self.marketplace and self.marketplace_id):\n            try:\n                marketplace_option = MarketPlaceOptions[\n                    self.marketplace.upper()\n                ]\n                self.url = marketplace_option.build_url(self.marketplace_id)\n            except KeyError:\n                raise PricingResearchException(\n                    f'No URL pattern available for marketplace: {self.marketplace}'\n                )\n            except Exception as e:\n                raise PricingResearchException(\n                    f'Unexpected error setting URL: {e}'\n                )\n        return self\n\n    @model_validator(mode='after')\n    def extract_marketplace_from_url(self) -&gt; 'PricingResearch':\n        \"\"\"\n        Extracts and sets the marketplace ID from the URL if not explicitly provided.\n\n        Returns:\n            PricingResearch: The instance of the PricingResearch model.\n\n        Raises:\n            PricingResearchException: If unable to extract marketplace ID from the URL.\n        \"\"\"\n        try:\n            if self.url and not self.marketplace:\n                parsed_url = urlparse(str(self.url))\n                for option in MarketPlaceOptions:\n                    marketplace_name = option.name.lower().replace('_', '')\n                    if marketplace_name in parsed_url.geturl():\n                        self.marketplace = option.name.lower()\n                        break\n        except Exception as e:\n            raise PricingResearchException(\n                f'Error while extracting marketplace from URL: {e}'\n            )\n        return self\n\n    @model_validator(mode='after')\n    def extract_marketplace_id_from_url(self) -&gt; 'PricingResearch':\n        \"\"\"\n        Extracts and sets the marketplace from the URL if not explicitly provided.\n\n        Returns:\n            PricingResearch: The instance of the PricingResearch model.\n\n        Raises:\n            PricingResearchException: If unable to extract marketplace ID from the URL.\n        \"\"\"\n        try:\n            if self.url and not self.marketplace_id:\n                url = str(self.url)\n                for option in MarketPlaceOptions:\n                    marketplace_name = option.name.lower().replace('_', '')\n                    if marketplace_name in url and option.url_pattern:\n                        marketplace_id_mask = re.escape(\n                            option.url_pattern\n                        ).replace(r'\\{marketplace_id\\}', '(.*)')\n                        if marketplace_id_mask:\n                            match = re.match(marketplace_id_mask, url)\n                            if match:\n                                self.marketplace_id = match.group(1)\n                                break\n        except Exception as e:\n            raise PricingResearchException(\n                f'Error while extracting marketplace ID from URL: {e}'\n            )\n        return self\n\n    def update_research_data(self, result: list) -&gt; bool:\n        \"\"\"\n        Updates the research data with the result from the strategy execution.\n\n        Args:\n            result (list): The list of seller data obtained from the strategy execution.\n\n        Returns:\n            bool: True if the data was successfully updated, False otherwise.\n\n        Raises:\n            PricingResearchException: If an error occurs during the update.\n        \"\"\"\n\n        is_research_updated = False\n        try:\n            if result:\n                self.sellers = result\n                first_result = result[0] if result else {}\n                self.marketplace_id = first_result.get('marketplace_id')\n                self.description = first_result.get('description')\n                self.brand = first_result.get('brand')\n                self.category = first_result.get('category')\n                self.conducted_at = datetime.now(tz=timezone.utc)\n                is_research_updated = True\n        except Exception as e:\n            raise PricingResearchException(\n                f'Error while updating research data: {e}'\n            )\n\n        return is_research_updated\n\n    @property\n    def expired(self) -&gt; bool:\n        \"\"\"\n        Determines if the current research data is expired based on the update delay.\n\n        Returns:\n            bool: True if the data is expired, False otherwise.\n        \"\"\"\n\n        is_expired = False\n        try:\n            is_expired = self.conducted_at + timedelta(\n                seconds=update_delay\n            ) &lt; datetime.now(tz=timezone.utc)\n        except Exception as e:\n            raise PricingResearchException(\n                f'Error while checking if research data is expired: {e}'\n            )\n\n        return is_expired\n</code></pre>"},{"location":"schemas/pricing-research/#kami_pricing_analytics.schemas.PricingResearch.expired","title":"<code>expired: bool</code>  <code>property</code>","text":"<p>Determines if the current research data is expired based on the update delay.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data is expired, False otherwise.</p>"},{"location":"schemas/pricing-research/#kami_pricing_analytics.schemas.PricingResearch.ensure_url_or_marketplace","title":"<code>ensure_url_or_marketplace()</code>","text":"<p>Validates the presence of either a URL or marketplace and marketplace_id.</p> <p>Returns:</p> Name Type Description <code>PricingResearch</code> <code>PricingResearch</code> <p>The instance of the PricingResearch model.</p> <p>Raises:</p> Type Description <code>PricingResearchException</code> <p>If neither URL nor marketplace and marketplace_id are provided.</p> Source code in <code>kami_pricing_analytics/schemas/pricing_research.py</code> <pre><code>@model_validator(mode='after')\ndef ensure_url_or_marketplace(self) -&gt; 'PricingResearch':\n    \"\"\"\n    Validates the presence of either a URL or marketplace and marketplace_id.\n\n    Returns:\n        PricingResearch: The instance of the PricingResearch model.\n\n    Raises:\n        PricingResearchException: If neither URL nor marketplace and marketplace_id are provided.\n    \"\"\"\n    if self.url:\n        return self\n\n    if not self.marketplace or not self.marketplace_id:\n        raise PricingResearchException(\n            'Either Product URL or marketplace and marketplace_id is required to conduct research.'\n        )\n\n    return self\n</code></pre>"},{"location":"schemas/pricing-research/#kami_pricing_analytics.schemas.PricingResearch.extract_marketplace_from_url","title":"<code>extract_marketplace_from_url()</code>","text":"<p>Extracts and sets the marketplace ID from the URL if not explicitly provided.</p> <p>Returns:</p> Name Type Description <code>PricingResearch</code> <code>PricingResearch</code> <p>The instance of the PricingResearch model.</p> <p>Raises:</p> Type Description <code>PricingResearchException</code> <p>If unable to extract marketplace ID from the URL.</p> Source code in <code>kami_pricing_analytics/schemas/pricing_research.py</code> <pre><code>@model_validator(mode='after')\ndef extract_marketplace_from_url(self) -&gt; 'PricingResearch':\n    \"\"\"\n    Extracts and sets the marketplace ID from the URL if not explicitly provided.\n\n    Returns:\n        PricingResearch: The instance of the PricingResearch model.\n\n    Raises:\n        PricingResearchException: If unable to extract marketplace ID from the URL.\n    \"\"\"\n    try:\n        if self.url and not self.marketplace:\n            parsed_url = urlparse(str(self.url))\n            for option in MarketPlaceOptions:\n                marketplace_name = option.name.lower().replace('_', '')\n                if marketplace_name in parsed_url.geturl():\n                    self.marketplace = option.name.lower()\n                    break\n    except Exception as e:\n        raise PricingResearchException(\n            f'Error while extracting marketplace from URL: {e}'\n        )\n    return self\n</code></pre>"},{"location":"schemas/pricing-research/#kami_pricing_analytics.schemas.PricingResearch.extract_marketplace_id_from_url","title":"<code>extract_marketplace_id_from_url()</code>","text":"<p>Extracts and sets the marketplace from the URL if not explicitly provided.</p> <p>Returns:</p> Name Type Description <code>PricingResearch</code> <code>PricingResearch</code> <p>The instance of the PricingResearch model.</p> <p>Raises:</p> Type Description <code>PricingResearchException</code> <p>If unable to extract marketplace ID from the URL.</p> Source code in <code>kami_pricing_analytics/schemas/pricing_research.py</code> <pre><code>@model_validator(mode='after')\ndef extract_marketplace_id_from_url(self) -&gt; 'PricingResearch':\n    \"\"\"\n    Extracts and sets the marketplace from the URL if not explicitly provided.\n\n    Returns:\n        PricingResearch: The instance of the PricingResearch model.\n\n    Raises:\n        PricingResearchException: If unable to extract marketplace ID from the URL.\n    \"\"\"\n    try:\n        if self.url and not self.marketplace_id:\n            url = str(self.url)\n            for option in MarketPlaceOptions:\n                marketplace_name = option.name.lower().replace('_', '')\n                if marketplace_name in url and option.url_pattern:\n                    marketplace_id_mask = re.escape(\n                        option.url_pattern\n                    ).replace(r'\\{marketplace_id\\}', '(.*)')\n                    if marketplace_id_mask:\n                        match = re.match(marketplace_id_mask, url)\n                        if match:\n                            self.marketplace_id = match.group(1)\n                            break\n    except Exception as e:\n        raise PricingResearchException(\n            f'Error while extracting marketplace ID from URL: {e}'\n        )\n    return self\n</code></pre>"},{"location":"schemas/pricing-research/#kami_pricing_analytics.schemas.PricingResearch.set_url","title":"<code>set_url()</code>","text":"<p>Sets the product URL based on the marketplace and marketplace_id if not provided.</p> <p>Returns:</p> Name Type Description <code>PricingResearch</code> <code>PricingResearch</code> <p>The instance of the PricingResearch model.</p> <p>Raises:</p> Type Description <code>PricingResearchException</code> <p>If unable to set the URL due to missing configuration.</p> Source code in <code>kami_pricing_analytics/schemas/pricing_research.py</code> <pre><code>@model_validator(mode='after')\ndef set_url(self) -&gt; 'PricingResearch':\n    \"\"\"\n    Sets the product URL based on the marketplace and marketplace_id if not provided.\n\n    Returns:\n        PricingResearch: The instance of the PricingResearch model.\n\n    Raises:\n        PricingResearchException: If unable to set the URL due to missing configuration.\n    \"\"\"\n    if not self.url and (self.marketplace and self.marketplace_id):\n        try:\n            marketplace_option = MarketPlaceOptions[\n                self.marketplace.upper()\n            ]\n            self.url = marketplace_option.build_url(self.marketplace_id)\n        except KeyError:\n            raise PricingResearchException(\n                f'No URL pattern available for marketplace: {self.marketplace}'\n            )\n        except Exception as e:\n            raise PricingResearchException(\n                f'Unexpected error setting URL: {e}'\n            )\n    return self\n</code></pre>"},{"location":"schemas/pricing-research/#kami_pricing_analytics.schemas.PricingResearch.update_research_data","title":"<code>update_research_data(result)</code>","text":"<p>Updates the research data with the result from the strategy execution.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>list</code> <p>The list of seller data obtained from the strategy execution.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data was successfully updated, False otherwise.</p> <p>Raises:</p> Type Description <code>PricingResearchException</code> <p>If an error occurs during the update.</p> Source code in <code>kami_pricing_analytics/schemas/pricing_research.py</code> <pre><code>def update_research_data(self, result: list) -&gt; bool:\n    \"\"\"\n    Updates the research data with the result from the strategy execution.\n\n    Args:\n        result (list): The list of seller data obtained from the strategy execution.\n\n    Returns:\n        bool: True if the data was successfully updated, False otherwise.\n\n    Raises:\n        PricingResearchException: If an error occurs during the update.\n    \"\"\"\n\n    is_research_updated = False\n    try:\n        if result:\n            self.sellers = result\n            first_result = result[0] if result else {}\n            self.marketplace_id = first_result.get('marketplace_id')\n            self.description = first_result.get('description')\n            self.brand = first_result.get('brand')\n            self.category = first_result.get('category')\n            self.conducted_at = datetime.now(tz=timezone.utc)\n            is_research_updated = True\n    except Exception as e:\n        raise PricingResearchException(\n            f'Error while updating research data: {e}'\n        )\n\n    return is_research_updated\n</code></pre>"},{"location":"schemas/pricing-research/#pricing-research-exception","title":"Pricing Research Exception","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception class for errors related to the PricingResearch operations.</p> Source code in <code>kami_pricing_analytics/schemas/pricing_research.py</code> <pre><code>class PricingResearchException(Exception):\n    \"\"\"\n    Custom exception class for errors related to the PricingResearch operations.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"services/pricing-service/","title":"Pricing Service","text":"<p>This document provides details about Pricing Service functionality. Below is the auto-generated documentation for the <code>PricingService</code> class.</p> <p>               Bases: <code>BaseModel</code></p> <p>Service to manage pricing data research and storage operations, integrating strategies for data collection and storage mechanisms.</p> <p>Attributes:</p> Name Type Description <code>collector_option</code> <code>int</code> <p>Identifier for the strategy to use for data collection.</p> <code>strategy</code> <code>BaseCollector</code> <p>The strategy instance for data collection.</p> <code>store_result</code> <code>bool</code> <p>Flag to determine if results should be stored.</p> <code>storage_mode</code> <code>int</code> <p>Identifier for the storage mode to use.</p> <code>storage</code> <code>BaseStorage</code> <p>The storage instance for data management.</p> <code>research</code> <code>PricingResearch</code> <p>The research data to process.</p> Source code in <code>kami_pricing_analytics/services/pricing_service.py</code> <pre><code>class PricingService(BaseModel):\n    \"\"\"\n    Service to manage pricing data research and storage operations, integrating\n    strategies for data collection and storage mechanisms.\n\n    Attributes:\n        collector_option (int): Identifier for the strategy to use for data collection.\n        strategy (BaseCollector): The strategy instance for data collection.\n        store_result (bool): Flag to determine if results should be stored.\n        storage_mode (int): Identifier for the storage mode to use.\n        storage (BaseStorage): The storage instance for data management.\n        research (PricingResearch): The research data to process.\n    \"\"\"\n\n    collector_option: int = Field(default=CollectorOptions.WEB_SCRAPING.value)\n    strategy: BaseCollector = Field(default=None)\n\n    store_result: bool = Field(default=False)\n    storage_mode: int = Field(default=0)\n    storage: BaseStorage = Field(default=None)\n\n    research: PricingResearch = Field(default=None)\n\n    model_config = ConfigDict(\n        title='Pricing Service',\n        from_attributes=True,\n        use_enum_values=True,\n        str_strip_whitespace=True,\n    )\n\n    @model_validator(mode='after')\n    def set_strategy(self) -&gt; 'PricingService':\n        \"\"\"\n        Sets the strategy based on the current strategy option and research URL.\n\n        Raises:\n            PricingServiceException: If there is an error in setting up the strategy.\n\n        Returns:\n            PricingService: The instance of this service with an updated strategy.\n        \"\"\"\n        try:\n            self.strategy = CollectorFactory.get_strategy(\n                collector_option=self.collector_option,\n                product_url=str(self.research.url),\n            )\n        except ValueError as e:\n            raise PricingServiceException(\n                f'Value Error while setting strategy: {e}'\n            )\n        except Exception as e:\n            raise PricingServiceException(\n                f'Unexpected error while setting strategy: {e}'\n            )\n\n        return self\n\n    @model_validator(mode='after')\n    def set_storage(self) -&gt; 'PricingService':\n        \"\"\"\n        Sets the storage mode based on the current storage mode setting and store_result flag.\n\n        Raises:\n            PricingServiceException: If there is an error in setting up the storage.\n\n        Returns:\n            PricingService: The instance of this service with an updated storage setting.\n        \"\"\"\n\n        try:\n            if self.store_result:\n                self.storage = StorageFactory.get_mode(mode=self.storage_mode)\n        except ValueError as e:\n            raise PricingServiceException(\n                f'Value Error while setting storage: {e}'\n            )\n        except Exception as e:\n            raise PricingServiceException(\n                f'Unexpected error while setting storage: {e}'\n            )\n\n        return self\n\n    async def conduct_research(self) -&gt; bool:\n        \"\"\"\n        Conducts the research using the assigned strategy and updates the research data.\n\n        Raises:\n            PricingServiceException: If there is an error during the research process.\n\n        Returns:\n            bool: True if the research was successful, False otherwise.\n        \"\"\"\n\n        is_conducted = False\n\n        try:\n            result = await self.strategy.execute()\n            self.research.update_research_data(result)\n            is_conducted = True\n        except ValueError as e:\n            raise PricingServiceException(\n                f'Value Error while conducting research: {e}'\n            )\n        except Exception as e:\n            raise PricingServiceException(\n                f'Unexpected error while conducting research: {e}'\n            )\n\n        return is_conducted\n\n    async def store_research(self) -&gt; bool:\n        \"\"\"\n        Stores the research data using the configured storage mode if storage is enabled.\n\n        Raises:\n            PricingServiceException: If there is an error during the storage process.\n\n        Returns:\n            bool: True if the storage was successful, False otherwise.\n        \"\"\"\n        is_result_stored = False\n\n        try:\n            if self.store_result:\n                research_data = self.research.model_dump_json(\n                    exclude={'model_config'}\n                )\n                research_data = json.loads(research_data)\n                research_data['strategy'] = CollectorOptions(\n                    self.collector_option\n                ).name\n                await self.storage.save(research_data)\n                is_result_stored = True\n        except ValueError as e:\n            raise PricingServiceException(\n                f'Value Error while storing research: {e}'\n            )\n        except Exception as e:\n            raise PricingServiceException(\n                f'Unexpected error while storing research: {e}'\n            )\n\n        return is_result_stored\n\n    async def retrieve_research(self) -&gt; bool:\n        \"\"\"\n        Retrieves the research data based on specified criteria and updates the research attribute.\n\n        Raises:\n            PricingServiceException: If there is an error during the retrieval process.\n\n        Returns:\n            bool: True if the retrieval was successful, False otherwise.\n        \"\"\"\n        is_research_retrieved = False\n        try:\n\n            criteria = {\n                'marketplace': self.research.marketplace,\n                'marketplace_id': self.research.marketplace_id,\n            }\n            results = await self.storage.retrieve(criteria)\n            if results:\n                research_data = results[0]\n                self.research = PricingResearch(**research_data)\n                is_research_retrieved = True\n        except ValueError as e:\n            raise ValueError(f'Value Error while retrieving research: {e}')\n        except Exception as e:\n            raise PricingServiceException(\n                f'Unexpected error while retrieving research: {e}'\n            )\n\n        return is_research_retrieved\n</code></pre>"},{"location":"services/pricing-service/#kami_pricing_analytics.services.PricingService.conduct_research","title":"<code>conduct_research()</code>  <code>async</code>","text":"<p>Conducts the research using the assigned strategy and updates the research data.</p> <p>Raises:</p> Type Description <code>PricingServiceException</code> <p>If there is an error during the research process.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the research was successful, False otherwise.</p> Source code in <code>kami_pricing_analytics/services/pricing_service.py</code> <pre><code>async def conduct_research(self) -&gt; bool:\n    \"\"\"\n    Conducts the research using the assigned strategy and updates the research data.\n\n    Raises:\n        PricingServiceException: If there is an error during the research process.\n\n    Returns:\n        bool: True if the research was successful, False otherwise.\n    \"\"\"\n\n    is_conducted = False\n\n    try:\n        result = await self.strategy.execute()\n        self.research.update_research_data(result)\n        is_conducted = True\n    except ValueError as e:\n        raise PricingServiceException(\n            f'Value Error while conducting research: {e}'\n        )\n    except Exception as e:\n        raise PricingServiceException(\n            f'Unexpected error while conducting research: {e}'\n        )\n\n    return is_conducted\n</code></pre>"},{"location":"services/pricing-service/#kami_pricing_analytics.services.PricingService.retrieve_research","title":"<code>retrieve_research()</code>  <code>async</code>","text":"<p>Retrieves the research data based on specified criteria and updates the research attribute.</p> <p>Raises:</p> Type Description <code>PricingServiceException</code> <p>If there is an error during the retrieval process.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the retrieval was successful, False otherwise.</p> Source code in <code>kami_pricing_analytics/services/pricing_service.py</code> <pre><code>async def retrieve_research(self) -&gt; bool:\n    \"\"\"\n    Retrieves the research data based on specified criteria and updates the research attribute.\n\n    Raises:\n        PricingServiceException: If there is an error during the retrieval process.\n\n    Returns:\n        bool: True if the retrieval was successful, False otherwise.\n    \"\"\"\n    is_research_retrieved = False\n    try:\n\n        criteria = {\n            'marketplace': self.research.marketplace,\n            'marketplace_id': self.research.marketplace_id,\n        }\n        results = await self.storage.retrieve(criteria)\n        if results:\n            research_data = results[0]\n            self.research = PricingResearch(**research_data)\n            is_research_retrieved = True\n    except ValueError as e:\n        raise ValueError(f'Value Error while retrieving research: {e}')\n    except Exception as e:\n        raise PricingServiceException(\n            f'Unexpected error while retrieving research: {e}'\n        )\n\n    return is_research_retrieved\n</code></pre>"},{"location":"services/pricing-service/#kami_pricing_analytics.services.PricingService.set_storage","title":"<code>set_storage()</code>","text":"<p>Sets the storage mode based on the current storage mode setting and store_result flag.</p> <p>Raises:</p> Type Description <code>PricingServiceException</code> <p>If there is an error in setting up the storage.</p> <p>Returns:</p> Name Type Description <code>PricingService</code> <code>PricingService</code> <p>The instance of this service with an updated storage setting.</p> Source code in <code>kami_pricing_analytics/services/pricing_service.py</code> <pre><code>@model_validator(mode='after')\ndef set_storage(self) -&gt; 'PricingService':\n    \"\"\"\n    Sets the storage mode based on the current storage mode setting and store_result flag.\n\n    Raises:\n        PricingServiceException: If there is an error in setting up the storage.\n\n    Returns:\n        PricingService: The instance of this service with an updated storage setting.\n    \"\"\"\n\n    try:\n        if self.store_result:\n            self.storage = StorageFactory.get_mode(mode=self.storage_mode)\n    except ValueError as e:\n        raise PricingServiceException(\n            f'Value Error while setting storage: {e}'\n        )\n    except Exception as e:\n        raise PricingServiceException(\n            f'Unexpected error while setting storage: {e}'\n        )\n\n    return self\n</code></pre>"},{"location":"services/pricing-service/#kami_pricing_analytics.services.PricingService.set_strategy","title":"<code>set_strategy()</code>","text":"<p>Sets the strategy based on the current strategy option and research URL.</p> <p>Raises:</p> Type Description <code>PricingServiceException</code> <p>If there is an error in setting up the strategy.</p> <p>Returns:</p> Name Type Description <code>PricingService</code> <code>PricingService</code> <p>The instance of this service with an updated strategy.</p> Source code in <code>kami_pricing_analytics/services/pricing_service.py</code> <pre><code>@model_validator(mode='after')\ndef set_strategy(self) -&gt; 'PricingService':\n    \"\"\"\n    Sets the strategy based on the current strategy option and research URL.\n\n    Raises:\n        PricingServiceException: If there is an error in setting up the strategy.\n\n    Returns:\n        PricingService: The instance of this service with an updated strategy.\n    \"\"\"\n    try:\n        self.strategy = CollectorFactory.get_strategy(\n            collector_option=self.collector_option,\n            product_url=str(self.research.url),\n        )\n    except ValueError as e:\n        raise PricingServiceException(\n            f'Value Error while setting strategy: {e}'\n        )\n    except Exception as e:\n        raise PricingServiceException(\n            f'Unexpected error while setting strategy: {e}'\n        )\n\n    return self\n</code></pre>"},{"location":"services/pricing-service/#kami_pricing_analytics.services.PricingService.store_research","title":"<code>store_research()</code>  <code>async</code>","text":"<p>Stores the research data using the configured storage mode if storage is enabled.</p> <p>Raises:</p> Type Description <code>PricingServiceException</code> <p>If there is an error during the storage process.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the storage was successful, False otherwise.</p> Source code in <code>kami_pricing_analytics/services/pricing_service.py</code> <pre><code>async def store_research(self) -&gt; bool:\n    \"\"\"\n    Stores the research data using the configured storage mode if storage is enabled.\n\n    Raises:\n        PricingServiceException: If there is an error during the storage process.\n\n    Returns:\n        bool: True if the storage was successful, False otherwise.\n    \"\"\"\n    is_result_stored = False\n\n    try:\n        if self.store_result:\n            research_data = self.research.model_dump_json(\n                exclude={'model_config'}\n            )\n            research_data = json.loads(research_data)\n            research_data['strategy'] = CollectorOptions(\n                self.collector_option\n            ).name\n            await self.storage.save(research_data)\n            is_result_stored = True\n    except ValueError as e:\n        raise PricingServiceException(\n            f'Value Error while storing research: {e}'\n        )\n    except Exception as e:\n        raise PricingServiceException(\n            f'Unexpected error while storing research: {e}'\n        )\n\n    return is_result_stored\n</code></pre>"},{"location":"services/pricing-service/#pricing-service-exception","title":"Pricing Service Exception","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception class for PricingService-related errors.</p> Source code in <code>kami_pricing_analytics/services/pricing_service.py</code> <pre><code>class PricingServiceException(Exception):\n    \"\"\"\n    Custom exception class for PricingService-related errors.\n    \"\"\"\n\n    pass\n</code></pre>"}]}